{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>The BibbleVM Architecture</li> <li>Instructions</li> </ul>"},{"location":"404/","title":"404 - Not Found","text":""},{"location":"architecture/","title":"The BibbleVM Architecture","text":"<p>This page describes an abstract machine, not any particular implementation of BibbleVM.</p>"},{"location":"architecture/#the-bibble-bytecode-executable-format","title":"The Bibble Bytecode Executable Format","text":"<p>Also known as the <code>bbx</code> format. Compiled code for the BibbleVM is represented using a hardware- and OS-independent binary format, typically stored in a file.  The <code>bbx</code> file format defines the data, instructions and exported symbols within a BibbleVM executable or library.  This format also includes details such as byte ordering that might not exist in a platform-dependent object file format.  The <code>bbx</code> format is covered in more detail in \"The bbx File Format\".</p>"},{"location":"architecture/#data-types","title":"Data Types","text":"<p>BibbleVM operates on 4 kinds of types: primitive types, the handle type, the pointer type and reference types. However, these are all stored in the same 64-bit value slots. The primitive types are: integral types and floating-point types (see below).  BibbleVM expects that all type checking is done at compile time, and does not have to be done by the VM.  Values do not need to be inspectable to have their types determined at runtime.  Instead, the instruction set distinguishes its operand types using instructions intended to operate on specific types. For example, <code>add</code> and <code>fadd</code> are both instructions that add two numeric values and produce numeric results, but they're specialized for different operand types: integer and float respectively.  BibbleVM has explicit support for objects. An object is a dynamically allocated class whose memory is handled by the automatic storage manager and its VM type is <code>reference</code>. BibbleVM also has explicit support for manual memory allocation. Manual memory is mainly meant for array allocation, but can be used for small structures to save the automatic storage manager time.  Its VM type is <code>pointer</code>, but is not required to be represented as a real platform-dependent memory pointer.</p>"},{"location":"architecture/#integral-types","title":"Integral Types","text":"<p>Integrals in BibbleVM are 64-bit signed two's-complement integers with instructions to shrink their values down to 8-, 16- or 32-bit.</p>"},{"location":"architecture/#floating-point-types","title":"Floating-Point Types","text":"<p>Floating-points (or \"floats\") in BibbleVM are 64-bit double-precision format IEEE 754 values as specified in the IEEE standard.</p>"},{"location":"architecture/#the-handle-type","title":"The Handle Type","text":"<p>Unfortunately, BibbleVM can't be fully platform-independent, and at a certain point, it must interact with its host platform. The handle type provides a way to pass around opaque platform-dependent values, such as Windows <code>HANDLE</code>s or Unix file descriptors, without exposing their internals.  The handle type is stored as a 64-bit value like other VM values.  In combination with implementation-defined trap routines, handles act as the bridge between low-level libraries and the underlying systems, usually without requiring platform-dependent code to be loaded.</p>"},{"location":"architecture/#the-pointer-type","title":"The Pointer Type","text":"<p>The pointer type represents manually managed memory in BibbleVM. A pointer value refers to a region of memory allocated manually through the use of <code>alloc</code> instructions, and its lifetime is controlled entirely by the program. BibbleVM never automatically frees manual memory and never performs any pointer-based garbage collection.  The pointer type is stored as a 64-bit standard value, but its internal representation is implementation-defined. They are not required to correspond to raw machine addresses and may instead be offsets, handles into an internal heap or other abstract identifiers.  Unlike typical pointers, performing pointer arithmetic is not explicitly supported and will lead to undefined behavior.  Because pointer-based memory is untyped, BibbleVM performs no automatic type checking, but might perform automatic bounds checks or pointer validation depending on safety settings. All safety and memory discipline is the responsibility of the compiler and user code. Typical uses include array storage, temporary buffers, and low-level data manipulation that benefits from avoiding garbage collection overhead.  BibbleVM instructions that interact with pointer-based memory operate on raw bytes and an offset from the base pointer.</p>"},{"location":"architecture/#the-reference-type","title":"The Reference Type","text":"<p>The reference type represents objects allocated by the automatic storage manager. A reference value is essentially a pointer to a heap-allocated instance of a class, and its lifetime is tracked by BibbleVM's automatic storage manager. A reference always identifies a fully typed object with a known class layout including fields, methods and an optional destructor.  The reference type is stored as a 64-bit standard value, but unlike pointers, the VM is responsible for their reachability analysis and destruction using conservative garbage collection.  Because references carry type information, instructions that operate on objects might perform automatic type checking depending on safety settings. BibbleVM still offers instructions to let the program perform manual type checking. BibbleVM ensures memory safety for automatically managed objects.</p>"},{"location":"architecture/#runtime-data-areas","title":"Runtime Data Areas","text":"<p>BibbleVM defines several runtime data areas that are used during the execution of a program. Some of these are global while others are per thread. Global data areas are created when the VM starts and destroyed when the VM exits and per thread data areas are created when a thread is created and destroyed when the thread exits.</p>"},{"location":"architecture/#the-acc-register","title":"The <code>acc</code> Register","text":"<p><code>acc</code> is short for <code>accumulator</code>. Each BibbleVM thread has its own <code>acc</code> register which holds exactly one 64-bit value. The <code>acc</code> register is volatile: its contents are not preserved across calls. During a function call, the caller must assume the contents of the <code>acc</code> register is overridden by the callee.</p>"},{"location":"architecture/#the-sp-register","title":"The <code>sp</code> Register","text":""},{"location":"bbx-format/","title":"Bbx format","text":"<p>hi</p>"},{"location":"instructions/","title":"The BibbleVM Instruction Set","text":"<p>This page gives details about the format of each instruction and the operation it performs.</p>"},{"location":"instructions/#the-meaning-of-must","title":"The Meaning of \"must\"","text":"<p>The description of each instruction is always given in the context of bytecode following the constraints of The Code Section. In the descriptions of many instructions, it is stated that something \"must\" or \"must not\" be the case: \"Both <code>a</code> and <code>b</code> must be 64-bit integers.\" If some constraint (a \"must\" or \"must not\") in a description is not satisfied at runtime, behavior is undefined.</p>"},{"location":"instructions/#instruction-encoding","title":"Instruction Encoding","text":"<p>An instruction consists of a 1-3 byte opcode followed directly by zero or more operands. By default, an opcode consists of 1 byte, but when set to the hexadecimal value <code>FF</code>, the following 2 bytes are read and assembled as an extended opcode.  Operands are encoded in little-endian byte order in the same order as specified per instruction with no padding between them unless an instruction specifies otherwise.</p>"},{"location":"instructions/#format-of-instruction-descriptions","title":"Format of Instruction Descriptions","text":""},{"location":"instructions/#no-nav-example","title":"MNEMONIC","text":""},{"location":"instructions/#no-nav-example-opcode","title":"Opcode","text":"<p>Opcode for this instruction</p>"},{"location":"instructions/#no-nav-example-operation","title":"Operation","text":"<p>Short description of the instruction</p>"},{"location":"instructions/#no-nav-example-operands","title":"Operands","text":"<p>type op1, type op2</p>"},{"location":"instructions/#no-nav-example-acc","title":"Accumulator","text":"<p>oldvalue \u2192 newvalue</p>"},{"location":"instructions/#no-nav-example-sp","title":"Stack Pointer (Register)","text":"<p>oldvalue \u2192 newvalue</p>"},{"location":"instructions/#no-nav-example-stack","title":"Stack","text":"<p>[..., value1, value2] \u2192 [..., value3]</p>"},{"location":"instructions/#no-nav-example-desc","title":"Description","text":"<p>A longer description detailing constraints, the operation performed, the type of the data operated on, etc.</p>"},{"location":"instructions/#no-nav-example-errors","title":"Errors","text":"<p>A list of potential runtime errors and why they can happen.</p>"},{"location":"instructions/#no-nav-example-notes","title":"Notes","text":"<p>Comments not strictly part of the specification of an instruction are set aside as notes.  The instruction's mnemonic is its name. Its opcode is its numeric representation in hexadecimal form. If the opcode consists of 2 digits, it's a single byte opcode, if it consists of FF followed by 4 digits, it's a extended 3 byte opcode.</p>"},{"location":"instructions/#instructions","title":"Instructions","text":"<p>Disclaimer: I got really bored of writing 10 versions of the same arithmetic instructions, so I had an AI do it for me. This means that there could be some writing inconsistencies, but the overall logic of them should be accurate. Readers are encouraged to suggest edits to improve clarity and consistency for these instructions.</p>"},{"location":"instructions/#nop","title":"NOP","text":""},{"location":"instructions/#no-nav-nop","title":"Opcode","text":"<p>0x00</p>"},{"location":"instructions/#no-nav-nop-operation","title":"Operation","text":"<p>Do nothing</p>"},{"location":"instructions/#no-nav-nop-operands","title":"Operands","text":"<p>None</p>"},{"location":"instructions/#no-nav-nop-acc","title":"Accumulator","text":"<p>No change</p>"},{"location":"instructions/#no-nav-nop-stack","title":"Stack","text":"<p>No change</p>"},{"location":"instructions/#no-nav-nop-desc","title":"Description","text":"<p>Do nothing.</p>"},{"location":"instructions/#hlt","title":"HLT","text":""},{"location":"instructions/#no-nav-hlt","title":"Opcode","text":"<p>0x01</p>"},{"location":"instructions/#no-nav-hlt-operation","title":"Operation","text":"<p>Halt execution</p>"},{"location":"instructions/#no-nav-hlt-operands","title":"Operands","text":"<p>i8 exitcode</p>"},{"location":"instructions/#no-nav-hlt-acc","title":"Accumulator","text":"<p>No change</p>"},{"location":"instructions/#no-nav-hlt-stack","title":"Stack","text":"<p>No change</p>"},{"location":"instructions/#no-nav-hlt-desc","title":"Description","text":"<p>Forcibly terminates the current BibbleVM.</p>"},{"location":"instructions/#no-nav-hlt-notes","title":"Notes","text":"<p>Even though this terminates the BibbleVM, it doesn't necessarily terminate the host process running the it.</p>"},{"location":"instructions/#trap","title":"TRAP","text":""},{"location":"instructions/#no-nav-trap","title":"Opcode","text":"<p>0x02</p>"},{"location":"instructions/#no-nav-trap-operation","title":"Operation","text":"<p>Execute a implementation-defined VM trap routine</p>"},{"location":"instructions/#no-nav-trap-operands","title":"Operands","text":"<p>i8 code</p>"},{"location":"instructions/#no-nav-trap-acc","title":"Accumulator","text":"<p>Implementation-defined</p>"},{"location":"instructions/#no-nav-trap-stack","title":"Stack","text":"<p>Implementation-defined</p>"},{"location":"instructions/#no-nav-trap-desc","title":"Description","text":"<p>Executes an implementation-defined VM routine identified by <code>code</code>.</p>"},{"location":"instructions/#no-nav-trap-notes","title":"Notes","text":"<p>Intended for use by standard library implementations. Not typically used in user code.</p>"},{"location":"instructions/#trap_if_zero","title":"TRAP_IF_ZERO","text":""},{"location":"instructions/#no-nav-trap_if_zero","title":"Opcode","text":"<p>0x03</p>"},{"location":"instructions/#no-nav-trap_if_zero-operation","title":"Operation","text":"<p>Execute a implementation-defined VM trap routine if accumulator is 0</p>"},{"location":"instructions/#no-nav-trap_if_zero-operands","title":"Operands","text":"<p>i8 code</p>"},{"location":"instructions/#no-nav-trap_if_zero-acc","title":"Accumulator","text":"<p>x \u2192 Implementation-defined if x == 0</p>"},{"location":"instructions/#no-nav-trap_if_zero-stack","title":"Stack","text":"<p>Implementation-defined</p>"},{"location":"instructions/#no-nav-trap_if_zero-desc","title":"Description","text":"<p>If the value in accumulator is equal to 0, executes an implementation-defined VM routine identified by <code>code</code>. Otherwise, does nothing.</p>"},{"location":"instructions/#no-nav-trap_if_zero-notes","title":"Notes","text":"<p>Intended for use by standard library implementations. Not typically used in user code.</p>"},{"location":"instructions/#trap_if_not_zero","title":"TRAP_IF_NOT_ZERO","text":""},{"location":"instructions/#no-nav-trap_if_not_zero","title":"Opcode","text":"<p>0x04</p>"},{"location":"instructions/#no-nav-trap_if_not_zero-operation","title":"Operation","text":"<p>Execute a implementation-defined VM trap routine if accumulator isn't 0</p>"},{"location":"instructions/#no-nav-trap_if_not_zero-operands","title":"Operands","text":"<p>i8 code</p>"},{"location":"instructions/#no-nav-trap_if_not_zero-acc","title":"Accumulator","text":"<p>x \u2192 Implementation-defined if x != 0</p>"},{"location":"instructions/#no-nav-trap_if_not_zero-stack","title":"Stack","text":"<p>Implementation-defined</p>"},{"location":"instructions/#no-nav-trap_if_not_zero-desc","title":"Description","text":"<p>If the value in accumulator isn't equal to 0, executes an implementation-defined VM routine identified by <code>code</code>. Otherwise, does nothing.</p>"},{"location":"instructions/#no-nav-trap_if_not_zero-notes","title":"Notes","text":"<p>Intended for use by standard library implementations. Not typically used in user code.</p>"},{"location":"instructions/#brk","title":"BRK","text":""},{"location":"instructions/#no-nav-brk","title":"Opcode","text":"<p>0x05</p>"},{"location":"instructions/#no-nav-brk-operation","title":"Operation","text":"<p>Trigger debug break</p>"},{"location":"instructions/#no-nav-brk-operands","title":"Operands","text":"<p>None</p>"},{"location":"instructions/#no-nav-brk-acc","title":"Accumulator","text":"<p>No change</p>"},{"location":"instructions/#no-nav-brk-stack","title":"Stack","text":"<p>No change</p>"},{"location":"instructions/#no-nav-brk-desc","title":"Description","text":"<p>When a debugger is attached, triggers a breakpoint. Otherwise does nothing.</p>"},{"location":"instructions/#add","title":"ADD","text":""},{"location":"instructions/#no-nav-add","title":"Opcode","text":"<p>0x10</p>"},{"location":"instructions/#no-nav-add-operation","title":"Operation","text":"<p>Add integers</p>"},{"location":"instructions/#no-nav-add-operands","title":"Operands","text":"<p>None</p>"},{"location":"instructions/#no-nav-add-acc","title":"Accumulator","text":"<p>a \u2192 a + b</p>"},{"location":"instructions/#no-nav-add-stack","title":"Stack","text":"<p>[..., b] \u2192 [...]</p>"},{"location":"instructions/#no-nav-add-desc","title":"Description","text":"<p>Both <code>a</code> and <code>b</code> must be 64-bit signed integers. <code>b</code> is popped from the stack and added to <code>a</code> directly in the accumulator. Overflow behavior is undefined, but never results in runtime errors.</p>"},{"location":"instructions/#sub","title":"SUB","text":""},{"location":"instructions/#no-nav-sub","title":"Opcode","text":"<p>0x11</p>"},{"location":"instructions/#no-nav-sub-operation","title":"Operation","text":"<p>Subtract integers</p>"},{"location":"instructions/#no-nav-sub-operands","title":"Operands","text":"<p>None</p>"},{"location":"instructions/#no-nav-sub-acc","title":"Accumulator","text":"<p>a \u2192 a - b</p>"},{"location":"instructions/#no-nav-sub-stack","title":"Stack","text":"<p>[..., b] \u2192 [...]</p>"},{"location":"instructions/#no-nav-sub-desc","title":"Description","text":"<p>Both <code>a</code> and <code>b</code> must be 64-bit signed integers. <code>b</code> is popped from the stack and subtracted from <code>a</code> directly in the accumulator. Overflow behavior is undefined, but never results in runtime errors.</p>"},{"location":"instructions/#mul","title":"MUL","text":""},{"location":"instructions/#no-nav-mul","title":"Opcode","text":"<p>0x12</p>"},{"location":"instructions/#no-nav-mul-operation","title":"Operation","text":"<p>Multiply integers</p>"},{"location":"instructions/#no-nav-mul-operands","title":"Operands","text":"<p>None</p>"},{"location":"instructions/#no-nav-mul-acc","title":"Accumulator","text":"<p>a \u2192 a * b</p>"},{"location":"instructions/#no-nav-mul-stack","title":"Stack","text":"<p>[..., b] \u2192 [...]</p>"},{"location":"instructions/#no-nav-mul-desc","title":"Description","text":"<p>Both <code>a</code> and <code>b</code> must be 64-bit signed integers. <code>b</code> is popped from the stack and <code>a</code> is multiplied by it directly in the accumulator. Overflow behavior is undefined, but never results in runtime errors.</p>"},{"location":"instructions/#div","title":"DIV","text":""},{"location":"instructions/#no-nav-div","title":"Opcode","text":"<p>0x13</p>"},{"location":"instructions/#no-nav-div-operation","title":"Operation","text":"<p>Divide integers</p>"},{"location":"instructions/#no-nav-div-operands","title":"Operands","text":"<p>None</p>"},{"location":"instructions/#no-nav-div-acc","title":"Accumulator","text":"<p>a \u2192 a / b</p>"},{"location":"instructions/#no-nav-div-stack","title":"Stack","text":"<p>[..., b] \u2192 [...]</p>"},{"location":"instructions/#no-nav-div-desc","title":"Description","text":"<p>Both <code>a</code> and <code>b</code> must be 64-bit signed integers. <code>b</code> is popped from the stack and <code>a</code> is divided by it directly in the accumulator. Division of the most negative 64-bit value by -1 produces a result that cannot be represented. This case is undefined behavior, but does not raise a runtime error.</p>"},{"location":"instructions/#no-nav-div-errors","title":"Errors","text":"<p>If the divisor is 0, causes a runtime error.</p>"},{"location":"instructions/#mod","title":"MOD","text":""},{"location":"instructions/#no-nav-mod","title":"Opcode","text":"<p>0x14</p>"},{"location":"instructions/#no-nav-mod-operation","title":"Operation","text":"<p>Modulo integers</p>"},{"location":"instructions/#no-nav-mod-operands","title":"Operands","text":"<p>None</p>"},{"location":"instructions/#no-nav-mod-acc","title":"Accumulator","text":"<p>a \u2192 result</p>"},{"location":"instructions/#no-nav-mod-stack","title":"Stack","text":"<p>[..., b] \u2192 [...]</p>"},{"location":"instructions/#no-nav-mod-desc","title":"Description","text":"<p>Both <code>a</code> and <code>b</code> must be 64-bit signed integers. <code>b</code> is popped from the stack. he result is <code>a - (a / b) * b</code> and is moved to the accumulator. Applying modulo to the most negative 64-bit value with a divisor of -1 is undefined due to the underlying division step, but does not raise a runtime error.</p>"},{"location":"instructions/#no-nav-mod-errors","title":"Errors","text":"<p>If the divisor is 0, causes a runtime error.</p>"},{"location":"instructions/#and","title":"AND","text":""},{"location":"instructions/#no-nav-and","title":"Opcode","text":"<p>0x15</p>"},{"location":"instructions/#no-nav-and-operation","title":"Operation","text":"<p>Bitwise AND integers</p>"},{"location":"instructions/#no-nav-and-operands","title":"Operands","text":"<p>None</p>"},{"location":"instructions/#no-nav-and-acc","title":"Accumulator","text":"<p>a \u2192 a &amp; b</p>"},{"location":"instructions/#no-nav-and-stack","title":"Stack","text":"<p>[..., b] \u2192 [...]</p>"},{"location":"instructions/#no-nav-and-desc","title":"Description","text":"<p>Both <code>a</code> and <code>b</code> must be 64-bit integers. <code>b</code> is popped from the stack and the accumulator is set to the result of bitwise AND (conjunction) of <code>a</code> and <code>b</code>.</p>"},{"location":"instructions/#or","title":"OR","text":""},{"location":"instructions/#no-nav-or","title":"Opcode","text":"<p>0x16</p>"},{"location":"instructions/#no-nav-or-operation","title":"Operation","text":"<p>Bitwise OR integers</p>"},{"location":"instructions/#no-nav-or-operands","title":"Operands","text":"<p>None</p>"},{"location":"instructions/#no-nav-or-acc","title":"Accumulator","text":"<p>a \u2192 a | b</p>"},{"location":"instructions/#no-nav-or-stack","title":"Stack","text":"<p>[..., b] \u2192 [...]</p>"},{"location":"instructions/#no-nav-or-desc","title":"Description","text":"<p>Both <code>a</code> and <code>b</code> must be 64-bit integers. <code>b</code> is popped from the stack and the accumulator is set to the result of bitwise OR of <code>a</code> and <code>b</code>.</p>"},{"location":"instructions/#xor","title":"XOR","text":""},{"location":"instructions/#no-nav-xor","title":"Opcode","text":"<p>0x17</p>"},{"location":"instructions/#no-nav-xor-operation","title":"Operation","text":"<p>Bitwise XOR integers</p>"},{"location":"instructions/#no-nav-xor-operands","title":"Operands","text":"<p>None</p>"},{"location":"instructions/#no-nav-xor-acc","title":"Accumulator","text":"<p>a \u2192 a ^ b</p>"},{"location":"instructions/#no-nav-xor-stack","title":"Stack","text":"<p>[..., b] \u2192 [...]</p>"},{"location":"instructions/#no-nav-xor-desc","title":"Description","text":"<p>Both <code>a</code> and <code>b</code> must be 64-bit integers. <code>b</code> is popped from the stack and the accumulator is set to the result of bitwise exclusive OR of <code>a</code> and <code>b</code>.</p>"},{"location":"instructions/#shl","title":"SHL","text":""},{"location":"instructions/#no-nav-shl","title":"Opcode","text":"<p>0x18</p>"},{"location":"instructions/#no-nav-shl-operation","title":"Operation","text":"<p>Shift left integer</p>"},{"location":"instructions/#no-nav-shl-operands","title":"Operands","text":"<p>None</p>"},{"location":"instructions/#no-nav-shl-acc","title":"Accumulator","text":"<p>a \u2192 a &lt;&lt; b</p>"},{"location":"instructions/#no-nav-shl-stack","title":"Stack","text":"<p>[..., b] \u2192 [...]</p>"},{"location":"instructions/#no-nav-shl-desc","title":"Description","text":"<p>Both <code>a</code> and <code>b</code> must be 64-bit integers. <code>b</code> is popped from the stack and the value in accumulator is shifted left by <code>s</code> bit positions, where <code>s</code> is the value of the low 6 bits of <code>b</code>.</p>"},{"location":"instructions/#shr","title":"SHR","text":""},{"location":"instructions/#no-nav-shr","title":"Opcode","text":"<p>0x19</p>"},{"location":"instructions/#no-nav-shr-operation","title":"Operation","text":"<p>Shift right integer</p>"},{"location":"instructions/#no-nav-shr-operands","title":"Operands","text":"<p>None</p>"},{"location":"instructions/#no-nav-shr-acc","title":"Accumulator","text":"<p>a \u2192 a &gt;&gt; b</p>"},{"location":"instructions/#no-nav-shr-stack","title":"Stack","text":"<p>[..., b] \u2192 [...]</p>"},{"location":"instructions/#no-nav-shr-desc","title":"Description","text":"<p>Both <code>a</code> and <code>b</code> must be 64-bit integers. <code>b</code> is popped from the stack and the value in accumulator is shifted right by <code>s</code> bit positions, where <code>s</code> is the value of the low 6 bits of <code>b</code>.</p>"},{"location":"instructions/#neg","title":"NEG","text":""},{"location":"instructions/#no-nav-neg","title":"Opcode","text":"<p>0x1A</p>"},{"location":"instructions/#no-nav-neg-operation","title":"Operation","text":"<p>Negate integer</p>"},{"location":"instructions/#no-nav-neg-operands","title":"Operands","text":"<p>None</p>"},{"location":"instructions/#no-nav-neg-acc","title":"Accumulator","text":"<p>a \u2192 -a</p>"},{"location":"instructions/#no-nav-neg-stack","title":"Stack","text":"<p>No change</p>"},{"location":"instructions/#no-nav-neg-desc","title":"Description","text":"<p><code>a</code> must be a 64-bit integer. The value in the accumulator is set to the negation of <code>a</code>. Negation is the same as subtraction from 0.</p>"},{"location":"instructions/#not","title":"NOT","text":""},{"location":"instructions/#no-nav-not","title":"Opcode","text":"<p>0x1B</p>"},{"location":"instructions/#no-nav-not-operation","title":"Operation","text":"<p>Bitwise NOT integer</p>"},{"location":"instructions/#no-nav-not-operands","title":"Operands","text":"<p>None</p>"},{"location":"instructions/#no-nav-not-acc","title":"Accumulator","text":"<p>a \u2192 ~a</p>"},{"location":"instructions/#no-nav-not-stack","title":"Stack","text":"<p>No change</p>"},{"location":"instructions/#no-nav-not-desc","title":"Description","text":"<p><code>a</code> must be a 64-bit integer. The value in the accumulator is set to the bitwise complement of <code>a</code> (all bits inverted).</p>"},{"location":"instructions/#add2","title":"ADD2","text":""},{"location":"instructions/#no-nav-add2","title":"Opcode","text":"<p>0x1C</p>"},{"location":"instructions/#no-nav-add2-operation","title":"Operation","text":"<p>Add integers</p>"},{"location":"instructions/#no-nav-add2-operands","title":"Operands","text":"<p>None</p>"},{"location":"instructions/#no-nav-add2-acc","title":"Accumulator","text":"<p>... \u2192 a + b</p>"},{"location":"instructions/#no-nav-add2-stack","title":"Stack","text":"<p>[..., a, b] \u2192 [...]</p>"},{"location":"instructions/#no-nav-add2-desc","title":"Description","text":"<p>Both <code>a</code> and <code>b</code> must be 64-bit integers. The values are popped from the stack. The result is <code>a + b</code> and is moved to the accumulator. Overflow behavior is undefined, but never results in runtime errors.</p>"},{"location":"instructions/#sub2","title":"SUB2","text":""},{"location":"instructions/#no-nav-sub2","title":"Opcode","text":"<p>0x1D</p>"},{"location":"instructions/#no-nav-sub2-operation","title":"Operation","text":"<p>Subtract integers</p>"},{"location":"instructions/#no-nav-sub2-operands","title":"Operands","text":"<p>None</p>"},{"location":"instructions/#no-nav-sub2-acc","title":"Accumulator","text":"<p>... \u2192 a - b</p>"},{"location":"instructions/#no-nav-sub2-stack","title":"Stack","text":"<p>[..., a, b] \u2192 [...]</p>"},{"location":"instructions/#no-nav-sub2-desc","title":"Description","text":"<p>Both <code>a</code> and <code>b</code> must be 64-bit integers. The values are popped from the stack. The result is <code>a - b</code> and is moved to the accumulator. Overflow behavior is undefined, but never results in runtime errors.</p>"},{"location":"instructions/#mul2","title":"MUL2","text":""},{"location":"instructions/#no-nav-mul2","title":"Opcode","text":"<p>0x1E</p>"},{"location":"instructions/#no-nav-mul2-operation","title":"Operation","text":"<p>Multiply integers</p>"},{"location":"instructions/#no-nav-mul2-operands","title":"Operands","text":"<p>None</p>"},{"location":"instructions/#no-nav-mul2-acc","title":"Accumulator","text":"<p>... \u2192 a * b</p>"},{"location":"instructions/#no-nav-mul2-stack","title":"Stack","text":"<p>[..., a, b] \u2192 [...]</p>"},{"location":"instructions/#no-nav-mul2-desc","title":"Description","text":"<p>Both <code>a</code> and <code>b</code> must be 64-bit integers. The values are popped from the stack. The result is <code>a * b</code> and is moved to the accumulator. Overflow behavior is undefined, but never results in runtime errors.</p>"},{"location":"instructions/#div2","title":"DIV2","text":""},{"location":"instructions/#no-nav-div2","title":"Opcode","text":"<p>0x1F</p>"},{"location":"instructions/#no-nav-div2-operation","title":"Operation","text":"<p>Divide integers</p>"},{"location":"instructions/#no-nav-div2-operands","title":"Operands","text":"<p>None</p>"},{"location":"instructions/#no-nav-div2-acc","title":"Accumulator","text":"<p>... \u2192 a / b</p>"},{"location":"instructions/#no-nav-div2-stack","title":"Stack","text":"<p>[..., a, b] \u2192 [...]</p>"},{"location":"instructions/#no-nav-div2-desc","title":"Description","text":"<p>Both <code>a</code> and <code>b</code> must be 64-bit integers. The values are popped from the stack. The result is <code>a / b</code> and is moved to the accumulator. Division of the most negative 64-bit value by -1 produces a result that cannot be represented. This case is undefined behavior, but does not raise a runtime error.</p>"},{"location":"instructions/#no-nav-div2-errors","title":"Errors","text":"<p>If the divisor is 0, causes a runtime error.</p>"},{"location":"instructions/#mod2","title":"MOD2","text":""},{"location":"instructions/#no-nav-mod2","title":"Opcode","text":"<p>0x20</p>"},{"location":"instructions/#no-nav-mod2-operation","title":"Operation","text":"<p>Modulo integers</p>"},{"location":"instructions/#no-nav-mod2-operands","title":"Operands","text":"<p>None</p>"},{"location":"instructions/#no-nav-mod2-acc","title":"Accumulator","text":"<p>... \u2192 result</p>"},{"location":"instructions/#no-nav-mod2-stack","title":"Stack","text":"<p>[..., a, b] \u2192 [...]</p>"},{"location":"instructions/#no-nav-mod2-desc","title":"Description","text":"<p>Both <code>a</code> and <code>b</code> must be 64-bit integers. The values are popped from the stack. The result is <code>a - (a / b) * b</code> and is moved to the accumulator. Applying modulo to the most negative 64-bit value with a divisor of -1 is undefined due to the underlying division step, but does not raise a runtime error.</p>"},{"location":"instructions/#no-nav-mod2-errors","title":"Errors","text":"<p>If the divisor is 0, causes a runtime error. None</p>"},{"location":"instructions/#and2","title":"AND2","text":""},{"location":"instructions/#no-nav-and2","title":"Opcode","text":"<p>0x21</p>"},{"location":"instructions/#no-nav-and2-operation","title":"Operation","text":"<p>Bitwise AND integers</p>"},{"location":"instructions/#no-nav-and2-operands","title":"Operands","text":"<p>None</p>"},{"location":"instructions/#no-nav-and2-acc","title":"Accumulator","text":"<p>... \u2192 a &amp; b</p>"},{"location":"instructions/#no-nav-and2-stack","title":"Stack","text":"<p>[..., a, b] \u2192 [...]</p>"},{"location":"instructions/#no-nav-and2-desc","title":"Description","text":"<p>Both <code>a</code> and <code>b</code> must be 64-bit integers. The values are popped from the stack. The result is the bitwise AND (conjunction) of <code>a</code> and <code>b</code> and is moved to the accumulator.</p>"},{"location":"instructions/#or2","title":"OR2","text":""},{"location":"instructions/#no-nav-or2","title":"Opcode","text":"<p>0x22</p>"},{"location":"instructions/#no-nav-or2-operation","title":"Operation","text":"<p>Bitwise OR integers</p>"},{"location":"instructions/#no-nav-or2-operands","title":"Operands","text":"<p>None</p>"},{"location":"instructions/#no-nav-or2-acc","title":"Accumulator","text":"<p>... \u2192 a | b</p>"},{"location":"instructions/#no-nav-or2-stack","title":"Stack","text":"<p>[..., a, b] \u2192 [...]</p>"},{"location":"instructions/#no-nav-or2-desc","title":"Description","text":"<p>Both <code>a</code> and <code>b</code> must be 64-bit integers. The values are popped from the stack. The result is the bitwise OR of <code>a</code> and <code>b</code> and is moved to the accumulator.</p>"},{"location":"instructions/#xor2","title":"XOR2","text":""},{"location":"instructions/#no-nav-xor2","title":"Opcode","text":"<p>0x23</p>"},{"location":"instructions/#no-nav-xor2-operation","title":"Operation","text":"<p>Bitwise XOR integers</p>"},{"location":"instructions/#no-nav-xor2-operands","title":"Operands","text":"<p>None</p>"},{"location":"instructions/#no-nav-xor2-acc","title":"Accumulator","text":"<p>... \u2192 a ^ b</p>"},{"location":"instructions/#no-nav-xor2-stack","title":"Stack","text":"<p>[..., a, b] \u2192 [...]</p>"},{"location":"instructions/#no-nav-xor2-desc","title":"Description","text":"<p>Both <code>a</code> and <code>b</code> must be 64-bit integers. The values are popped from the stack. The result is the bitwise exclusive OR of <code>a</code> and <code>b</code> and is moved to the accumulator.</p>"},{"location":"instructions/#shl2","title":"SHL2","text":""},{"location":"instructions/#no-nav-shl2","title":"Opcode","text":"<p>0x24</p>"},{"location":"instructions/#no-nav-shl2-operation","title":"Operation","text":"<p>Shift left integer</p>"},{"location":"instructions/#no-nav-shl2-operands","title":"Operands","text":"<p>None</p>"},{"location":"instructions/#no-nav-shl2-acc","title":"Accumulator","text":"<p>... \u2192 a &lt;&lt; b</p>"},{"location":"instructions/#no-nav-shl2-stack","title":"Stack","text":"<p>[..., a, b] \u2192 [...]</p>"},{"location":"instructions/#no-nav-shl2-desc","title":"Description","text":"<p>Both <code>a</code> and <code>b</code> must be 64-bit integers. The values are popped from the stack. The result is <code>a</code> shifted left by <code>s</code> bit positions, where <code>s</code> is the value of the low 6 bits of <code>b</code> and is moved to the accumulator.</p>"},{"location":"instructions/#shr2","title":"SHR2","text":""},{"location":"instructions/#no-nav-shr2","title":"Opcode","text":"<p>0x25</p>"},{"location":"instructions/#no-nav-shr2-operation","title":"Operation","text":"<p>Shift right integer</p>"},{"location":"instructions/#no-nav-shr2-operands","title":"Operands","text":"<p>None</p>"},{"location":"instructions/#no-nav-shr2-acc","title":"Accumulator","text":"<p>... \u2192 a &gt;&gt; b</p>"},{"location":"instructions/#no-nav-shr2-stack","title":"Stack","text":"<p>[..., a, b] \u2192 [...]</p>"},{"location":"instructions/#no-nav-shr2-desc","title":"Description","text":"<p>Both <code>a</code> and <code>b</code> must be 64-bit integers. The values are popped from the stack. The result is <code>a</code> shifted left by <code>s</code> bit positions, where <code>s</code> is the value of the low 6 bits of <code>b</code> and is moved to the accumulator.</p>"},{"location":"instructions/#add_st","title":"ADD_ST","text":""},{"location":"instructions/#no-nav-add_st","title":"Opcode","text":"<p>0x26</p>"},{"location":"instructions/#no-nav-add_st-operation","title":"Operation","text":"<p>Add integers</p>"},{"location":"instructions/#no-nav-add_st-operands","title":"Operands","text":"<p>None</p>"},{"location":"instructions/#no-nav-add_st-acc","title":"Accumulator","text":"<p>No change</p>"},{"location":"instructions/#no-nav-add_st-stack","title":"Stack","text":"<p>[..., a, b] \u2192 [..., a + b]</p>"},{"location":"instructions/#no-nav-add_st-desc","title":"Description","text":"<p>Both <code>a</code> and <code>b</code> must be 64-bit integers. The values are popped from the stack. The result is <code>a + b</code> and is pushed onto the stack. Overflow behavior is undefined, but never results in runtime errors.</p>"},{"location":"instructions/#sub_st","title":"SUB_ST","text":""},{"location":"instructions/#no-nav-sub_st","title":"Opcode","text":"<p>0x27</p>"},{"location":"instructions/#no-nav-sub_st-operation","title":"Operation","text":"<p>Subtract integers</p>"},{"location":"instructions/#no-nav-sub_st-operands","title":"Operands","text":"<p>None</p>"},{"location":"instructions/#no-nav-sub_st-acc","title":"Accumulator","text":"<p>No change</p>"},{"location":"instructions/#no-nav-sub_st-stack","title":"Stack","text":"<p>[..., a, b] \u2192 [..., a - b]</p>"},{"location":"instructions/#no-nav-sub_st-desc","title":"Description","text":"<p>Both <code>a</code> and <code>b</code> must be 64-bit integers. The values are popped from the stack. The result is <code>a - b</code> and is pushed onto the stack. Overflow behavior is undefined, but never results in runtime errors.</p>"},{"location":"instructions/#mul_st","title":"MUL_ST","text":""},{"location":"instructions/#no-nav-mul_st","title":"Opcode","text":"<p>0x28</p>"},{"location":"instructions/#no-nav-mul_st-operation","title":"Operation","text":"<p>Multiply integers</p>"},{"location":"instructions/#no-nav-mul_st-operands","title":"Operands","text":"<p>None</p>"},{"location":"instructions/#no-nav-mul_st-acc","title":"Accumulator","text":"<p>No change</p>"},{"location":"instructions/#no-nav-mul_st-stack","title":"Stack","text":"<p>[..., a, b] \u2192 [..., a * b]</p>"},{"location":"instructions/#no-nav-mul_st-desc","title":"Description","text":"<p>Both <code>a</code> and <code>b</code> must be 64-bit integers. The values are popped from the stack. The result is <code>a * b</code> and is pushed onto the stack. Overflow behavior is undefined, but never results in runtime errors.</p>"},{"location":"instructions/#div_st","title":"DIV_ST","text":""},{"location":"instructions/#no-nav-div_st","title":"Opcode","text":"<p>0x29</p>"},{"location":"instructions/#no-nav-div_st-operation","title":"Operation","text":"<p>Divide integers</p>"},{"location":"instructions/#no-nav-div_st-operands","title":"Operands","text":"<p>None</p>"},{"location":"instructions/#no-nav-div_st-acc","title":"Accumulator","text":"<p>No change</p>"},{"location":"instructions/#no-nav-div_st-stack","title":"Stack","text":"<p>[..., a, b] \u2192 [..., a / b]</p>"},{"location":"instructions/#no-nav-div_st-desc","title":"Description","text":"<p>Both <code>a</code> and <code>b</code> must be 64-bit integers. The values are popped from the stack. The result is <code>a / b</code> and is pushed onto the stack. Division of the most negative 64-bit value by -1 produces a result that cannot be represented. This case is undefined behavior, but does not raise a runtime error.</p>"},{"location":"instructions/#no-nav-div_st-errors","title":"Errors","text":"<p>If the divisor is 0, causes a runtime error.</p>"},{"location":"instructions/#mod_st","title":"MOD_ST","text":""},{"location":"instructions/#no-nav-mod_st","title":"Opcode","text":"<p>0x2A</p>"},{"location":"instructions/#no-nav-mod_st-operation","title":"Operation","text":"<p>Modulo integers</p>"},{"location":"instructions/#no-nav-mod_st-operands","title":"Operands","text":"<p>None</p>"},{"location":"instructions/#no-nav-mod_st-acc","title":"Accumulator","text":"<p>No change</p>"},{"location":"instructions/#no-nav-mod_st-stack","title":"Stack","text":"<p>[..., a, b] \u2192 [..., result]</p>"},{"location":"instructions/#no-nav-mod_st-desc","title":"Description","text":"<p>Both <code>a</code> and <code>b</code> must be 64-bit integers. The values are popped from the stack. The result is <code>a - (a / b) * b</code> and is pushed onto the stack. Applying modulo to the most negative 64-bit value with a divisor of -1 is undefined due to the underlying division step, but does not raise a runtime error.</p>"},{"location":"instructions/#no-nav-mod_st-errors","title":"Errors","text":"<p>If the divisor is 0, causes a runtime error.</p>"},{"location":"instructions/#and_st","title":"AND_ST","text":""},{"location":"instructions/#no-nav-and_st","title":"Opcode","text":"<p>0x2B</p>"},{"location":"instructions/#no-nav-and_st-operation","title":"Operation","text":"<p>Bitwise AND integers</p>"},{"location":"instructions/#no-nav-and_st-operands","title":"Operands","text":"<p>None</p>"},{"location":"instructions/#no-nav-and_st-acc","title":"Accumulator","text":"<p>No change</p>"},{"location":"instructions/#no-nav-and_st-stack","title":"Stack","text":"<p>[..., a, b] \u2192 [..., a &amp; b]</p>"},{"location":"instructions/#no-nav-and_st-desc","title":"Description","text":"<p>Both <code>a</code> and <code>b</code> must be 64-bit integers. The values are popped from the stack. The result is bitwise AND (conjunction) of <code>a</code> and <code>b</code> and is pushed onto the stack.</p>"},{"location":"instructions/#or_st","title":"OR_ST","text":""},{"location":"instructions/#no-nav-or_st","title":"Opcode","text":"<p>0x2C</p>"},{"location":"instructions/#no-nav-or_st-operation","title":"Operation","text":"<p>Bitwise OR integers</p>"},{"location":"instructions/#no-nav-or_st-operands","title":"Operands","text":"<p>None</p>"},{"location":"instructions/#no-nav-or_st-acc","title":"Accumulator","text":"<p>No change</p>"},{"location":"instructions/#no-nav-or_st-stack","title":"Stack","text":"<p>[..., a, b] \u2192 [..., a | b]</p>"},{"location":"instructions/#no-nav-or_st-desc","title":"Description","text":"<p>Both <code>a</code> and <code>b</code> must be 64-bit integers. The values are popped from the stack. The result is bitwise OR of <code>a</code> and <code>b</code> and is pushed onto the stack.</p>"},{"location":"instructions/#xor_st","title":"XOR_ST","text":""},{"location":"instructions/#no-nav-xor_st","title":"Opcode","text":"<p>0x2D</p>"},{"location":"instructions/#no-nav-xor_st-operation","title":"Operation","text":"<p>Bitwise XOR integers</p>"},{"location":"instructions/#no-nav-xor_st-operands","title":"Operands","text":"<p>None</p>"},{"location":"instructions/#no-nav-xor_st-acc","title":"Accumulator","text":"<p>No change</p>"},{"location":"instructions/#no-nav-xor_st-stack","title":"Stack","text":"<p>[..., a, b] \u2192 [..., a ^ b]</p>"},{"location":"instructions/#no-nav-xor_st-desc","title":"Description","text":"<p>Both <code>a</code> and <code>b</code> must be 64-bit integers. The values are popped from the stack. The result is bitwise exclusive OR of <code>a</code> and <code>b</code> and is pushed onto the stack.</p>"},{"location":"instructions/#shl_st","title":"SHL_ST","text":""},{"location":"instructions/#no-nav-shl_st","title":"Opcode","text":"<p>0x2E</p>"},{"location":"instructions/#no-nav-shl_st-operation","title":"Operation","text":"<p>Shift left integer</p>"},{"location":"instructions/#no-nav-shl_st-operands","title":"Operands","text":"<p>None</p>"},{"location":"instructions/#no-nav-shl_st-acc","title":"Accumulator","text":"<p>No change</p>"},{"location":"instructions/#no-nav-shl_st-stack","title":"Stack","text":"<p>[..., a, b] \u2192 [..., a &lt;&lt; b]</p>"},{"location":"instructions/#no-nav-shl_st-desc","title":"Description","text":"<p>Both <code>a</code> and <code>b</code> must be 64-bit integers. The values are popped from the stack. The result is <code>a</code> shifted left by <code>s</code> bit positions, where <code>s</code> is the value of the low 6 bits of <code>b</code> and is pushed onto the stack.</p>"},{"location":"instructions/#shr_st","title":"SHR_ST","text":""},{"location":"instructions/#no-nav-shr_st","title":"Opcode","text":"<p>0x2F</p>"},{"location":"instructions/#no-nav-shr_st-operation","title":"Operation","text":"<p>Shift right integer</p>"},{"location":"instructions/#no-nav-shr_st-operands","title":"Operands","text":"<p>None</p>"},{"location":"instructions/#no-nav-shr_st-acc","title":"Accumulator","text":"<p>No change</p>"},{"location":"instructions/#no-nav-shr_st-stack","title":"Stack","text":"<p>[..., a, b] \u2192 [..., a &gt;&gt; b]</p>"},{"location":"instructions/#no-nav-shr_st-desc","title":"Description","text":"<p>Both <code>a</code> and <code>b</code> must be 64-bit integers. The values are popped from the stack. The result is <code>a</code> shifted right by <code>s</code> bit positions, where <code>s</code> is the value of the low 6 bits of <code>b</code> and is pushed onto the stack.</p>"},{"location":"instructions/#neg_st","title":"NEG_ST","text":""},{"location":"instructions/#no-nav-neg_st","title":"Opcode","text":"<p>0x30</p>"},{"location":"instructions/#no-nav-neg_st-operation","title":"Operation","text":"<p>Negate integer</p>"},{"location":"instructions/#no-nav-neg_st-operands","title":"Operands","text":"<p>None</p>"},{"location":"instructions/#no-nav-neg_st-acc","title":"Accumulator","text":"<p>No change</p>"},{"location":"instructions/#no-nav-neg_st-stack","title":"Stack","text":"<p>[..., a] \u2192 [..., -a]</p>"},{"location":"instructions/#no-nav-neg_st-desc","title":"Description","text":"<p><code>a</code> must be a 64-bit integer. The top value of the stack is set to the negation of <code>a</code>. Negation is the same as subtraction from 0.</p>"},{"location":"instructions/#not_st","title":"NOT_ST","text":""},{"location":"instructions/#no-nav-not_st","title":"Opcode","text":"<p>0x31</p>"},{"location":"instructions/#no-nav-not_st-operation","title":"Operation","text":"<p>Bitwise NOT integer</p>"},{"location":"instructions/#no-nav-not_st-operands","title":"Operands","text":"<p>None</p>"},{"location":"instructions/#no-nav-not_st-acc","title":"Accumulator","text":"<p>No change</p>"},{"location":"instructions/#no-nav-not_st-stack","title":"Stack","text":"<p>[..., a] \u2192 [..., ~a]</p>"},{"location":"instructions/#no-nav-not_st-desc","title":"Description","text":"<p><code>a</code> must be a 64-bit integer. The top value of the stack is set to the bitwise complement of <code>a</code> (all bits inverted).</p>"},{"location":"instructions/#add_imm","title":"ADD_IMM","text":""},{"location":"instructions/#no-nav-add_imm","title":"Opcode","text":"<p>0x32</p>"},{"location":"instructions/#no-nav-add_imm-operation","title":"Operation","text":"<p>Add immediate to accumulator</p>"},{"location":"instructions/#no-nav-add_imm-operands","title":"Operands","text":"<p>i32 value</p>"},{"location":"instructions/#no-nav-add_imm-acc","title":"Accumulator","text":"<p>a \u2192 a + value</p>"},{"location":"instructions/#no-nav-add_imm-stack","title":"Stack","text":"<p>No change</p>"},{"location":"instructions/#no-nav-add_imm-desc","title":"Description","text":"<p><code>a</code> must be a 64-bit integer. The value in the accumulator is increased by the 32-bit immediate <code>value</code>. Overflow behavior is undefined, but never results in runtime errors.</p>"},{"location":"instructions/#sub_imm","title":"SUB_IMM","text":""},{"location":"instructions/#no-nav-sub_imm","title":"Opcode","text":"<p>0x33</p>"},{"location":"instructions/#no-nav-sub_imm-operation","title":"Operation","text":"<p>Subtract immediate from accumulator</p>"},{"location":"instructions/#no-nav-sub_imm-operands","title":"Operands","text":"<p>i32 value</p>"},{"location":"instructions/#no-nav-sub_imm-acc","title":"Accumulator","text":"<p>a \u2192 a - value</p>"},{"location":"instructions/#no-nav-sub_imm-stack","title":"Stack","text":"<p>No change</p>"},{"location":"instructions/#no-nav-sub_imm-desc","title":"Description","text":"<p><code>a</code> must be a 64-bit integer. The value in the accumulator is decreased by the 32-bit immediate <code>value</code>. Overflow behavior is undefined, but never results in runtime errors.</p>"},{"location":"instructions/#mul_imm","title":"MUL_IMM","text":""},{"location":"instructions/#no-nav-mul_imm","title":"Opcode","text":"<p>0x34</p>"},{"location":"instructions/#no-nav-mul_imm-operation","title":"Operation","text":"<p>Multiply accumulator by immediate</p>"},{"location":"instructions/#no-nav-mul_imm-operands","title":"Operands","text":"<p>i32 value</p>"},{"location":"instructions/#no-nav-mul_imm-acc","title":"Accumulator","text":"<p>a \u2192 a * value</p>"},{"location":"instructions/#no-nav-mul_imm-stack","title":"Stack","text":"<p>No change</p>"},{"location":"instructions/#no-nav-mul_imm-desc","title":"Description","text":"<p><code>a</code> must be a 64-bit integer. The value in the accumulator is multiplied by the 32-bit immediate <code>value</code>. Overflow behavior is undefined, but never results in runtime errors.</p>"},{"location":"instructions/#div_imm","title":"DIV_IMM","text":""},{"location":"instructions/#no-nav-div_imm","title":"Opcode","text":"<p>0x35</p>"},{"location":"instructions/#no-nav-div_imm-operation","title":"Operation","text":"<p>Divide accumulator by immediate</p>"},{"location":"instructions/#no-nav-div_imm-operands","title":"Operands","text":"<p>i32 value</p>"},{"location":"instructions/#no-nav-div_imm-acc","title":"Accumulator","text":"<p>a \u2192 a / value</p>"},{"location":"instructions/#no-nav-div_imm-stack","title":"Stack","text":"<p>No change</p>"},{"location":"instructions/#no-nav-div_imm-desc","title":"Description","text":"<p><code>a</code> must be a 64-bit integer. The accumulator is divided by the 32-bit immediate <code>value</code>. Division of the most negative 64-bit value by -1 produces a result that cannot be represented. This case is undefined behavior, but does not raise a runtime error.</p>"},{"location":"instructions/#no-nav-div_imm-errors","title":"Errors","text":"<p>If the divisor is 0, causes a runtime error.</p>"},{"location":"instructions/#mod_imm","title":"MOD_IMM","text":""},{"location":"instructions/#no-nav-mod_imm","title":"Opcode","text":"<p>0x36</p>"},{"location":"instructions/#no-nav-mod_imm-operation","title":"Operation","text":"<p>Modulo accumulator by immediate</p>"},{"location":"instructions/#no-nav-mod_imm-operands","title":"Operands","text":"<p>i32 value</p>"},{"location":"instructions/#no-nav-mod_imm-acc","title":"Accumulator","text":"<p>a \u2192 result</p>"},{"location":"instructions/#no-nav-mod_imm-stack","title":"Stack","text":"<p>No change</p>"},{"location":"instructions/#no-nav-mod_imm-desc","title":"Description","text":"<p><code>a</code> must be a 64-bit integer. The accumulator is set to the result of <code>a - (a / value) * value</code>. Applying modulo to the most negative 64-bit value with a divisor of -1 is undefined due to the underlying division step, but does not raise a runtime error.</p>"},{"location":"instructions/#no-nav-mod_imm-errors","title":"Errors","text":"<p>If the divisor is 0, causes a runtime error.</p>"},{"location":"instructions/#and_imm","title":"AND_IMM","text":""},{"location":"instructions/#no-nav-and_imm","title":"Opcode","text":"<p>0x37</p>"},{"location":"instructions/#no-nav-and_imm-operation","title":"Operation","text":"<p>Bitwise AND accumulator with immediate</p>"},{"location":"instructions/#no-nav-and_imm-operands","title":"Operands","text":"<p>i32 value</p>"},{"location":"instructions/#no-nav-and_imm-acc","title":"Accumulator","text":"<p>a \u2192 a &amp; value</p>"},{"location":"instructions/#no-nav-and_imm-stack","title":"Stack","text":"<p>No change</p>"},{"location":"instructions/#no-nav-and_imm-desc","title":"Description","text":"<p><code>a</code> must be a 64-bit integer. The value in the accumulator is set to the result of bitwise AND (conjunction) of <code>a</code> and the 32-bit immediate <code>value</code>.</p>"},{"location":"instructions/#or_imm","title":"OR_IMM","text":""},{"location":"instructions/#no-nav-or_imm","title":"Opcode","text":"<p>0x38</p>"},{"location":"instructions/#no-nav-or_imm-operation","title":"Operation","text":"<p>Bitwise OR accumulator with immediate</p>"},{"location":"instructions/#no-nav-or_imm-operands","title":"Operands","text":"<p>i32 value</p>"},{"location":"instructions/#no-nav-or_imm-acc","title":"Accumulator","text":"<p>a \u2192 a | value</p>"},{"location":"instructions/#no-nav-or_imm-stack","title":"Stack","text":"<p>No change</p>"},{"location":"instructions/#no-nav-or_imm-desc","title":"Description","text":"<p><code>a</code> must be a 64-bit integer. The value in the accumulator is set to the result of bitwise OR of <code>a</code> and the 32-bit immediate <code>value</code>.</p>"},{"location":"instructions/#xor_imm","title":"XOR_IMM","text":""},{"location":"instructions/#no-nav-xor_imm","title":"Opcode","text":"<p>0x39</p>"},{"location":"instructions/#no-nav-xor_imm-operation","title":"Operation","text":"<p>Bitwise XOR accumulator with immediate</p>"},{"location":"instructions/#no-nav-xor_imm-operands","title":"Operands","text":"<p>i32 value</p>"},{"location":"instructions/#no-nav-xor_imm-acc","title":"Accumulator","text":"<p>a \u2192 a ^ value</p>"},{"location":"instructions/#no-nav-xor_imm-stack","title":"Stack","text":"<p>No change</p>"},{"location":"instructions/#no-nav-xor_imm-desc","title":"Description","text":"<p><code>a</code> must be a 64-bit integer. The value in the accumulator is set to the result of bitwise exclusive OR of <code>a</code> and the 32-bit immediate <code>value</code>.</p>"},{"location":"instructions/#shl_imm","title":"SHL_IMM","text":""},{"location":"instructions/#no-nav-shl_imm","title":"Opcode","text":"<p>0x3A</p>"},{"location":"instructions/#no-nav-shl_imm-operation","title":"Operation","text":"<p>Shift left accumulator by immediate</p>"},{"location":"instructions/#no-nav-shl_imm-operands","title":"Operands","text":"<p>i32 value</p>"},{"location":"instructions/#no-nav-shl_imm-acc","title":"Accumulator","text":"<p>a \u2192 a &lt;&lt; value</p>"},{"location":"instructions/#no-nav-shl_imm-stack","title":"Stack","text":"<p>No change</p>"},{"location":"instructions/#no-nav-shl_imm-desc","title":"Description","text":"<p><code>a</code> must be a 64-bit integer. The value in the accumulator is shifted left by <code>s</code> bit positions, where <code>s</code> is the value of the low 6 bits of the 32-bit immediate <code>value</code>.</p>"},{"location":"instructions/#shr_imm","title":"SHR_IMM","text":""},{"location":"instructions/#no-nav-shr_imm","title":"Opcode","text":"<p>0x3B</p>"},{"location":"instructions/#no-nav-shr_imm-operation","title":"Operation","text":"<p>Shift right accumulator by immediate</p>"},{"location":"instructions/#no-nav-shr_imm-operands","title":"Operands","text":"<p>i32 value</p>"},{"location":"instructions/#no-nav-shr_imm-acc","title":"Accumulator","text":"<p>a \u2192 a &gt;&gt; value</p>"},{"location":"instructions/#no-nav-shr_imm-stack","title":"Stack","text":"<p>No change</p>"},{"location":"instructions/#no-nav-shr_imm-desc","title":"Description","text":"<p><code>a</code> must be a 64-bit integer. The value in the accumulator is shifted right by <code>s</code> bit positions, where <code>s</code> is the value of the low 6 bits of the 32-bit immediate <code>value</code>.</p>"},{"location":"instructions/#add_imm_st","title":"ADD_IMM_ST","text":""},{"location":"instructions/#no-nav-add_imm_st","title":"Opcode","text":"<p>0x3C</p>"},{"location":"instructions/#no-nav-add_imm_st-operation","title":"Operation","text":"<p>Add immediate to top of stack</p>"},{"location":"instructions/#no-nav-add_imm_st-operands","title":"Operands","text":"<p>i32 value</p>"},{"location":"instructions/#no-nav-add_imm_st-acc","title":"Accumulator","text":"<p>No change</p>"},{"location":"instructions/#no-nav-add_imm_st-stack","title":"Stack","text":"<p>[..., a] \u2192 [..., a + value]</p>"},{"location":"instructions/#no-nav-add_imm_st-desc","title":"Description","text":"<p><code>a</code> must be a 64-bit integer. The top value of the stack is increased by the 32-bit immediate <code>value</code>. Overflow behavior is undefined, but never results in runtime errors.</p>"},{"location":"instructions/#sub_imm_st","title":"SUB_IMM_ST","text":""},{"location":"instructions/#no-nav-sub_imm_st","title":"Opcode","text":"<p>0x3D</p>"},{"location":"instructions/#no-nav-sub_imm_st-operation","title":"Operation","text":"<p>Subtract immediate from top of stack</p>"},{"location":"instructions/#no-nav-sub_imm_st-operands","title":"Operands","text":"<p>i32 value</p>"},{"location":"instructions/#no-nav-sub_imm_st-acc","title":"Accumulator","text":"<p>No change</p>"},{"location":"instructions/#no-nav-sub_imm_st-stack","title":"Stack","text":"<p>[..., a] \u2192 [..., a - value]</p>"},{"location":"instructions/#no-nav-sub_imm_st-desc","title":"Description","text":"<p><code>a</code> must be a 64-bit integer. The top value of the stack is decreased by the 32-bit immediate <code>value</code>. Overflow behavior is undefined, but never results in runtime errors.</p>"},{"location":"instructions/#mul_imm_st","title":"MUL_IMM_ST","text":""},{"location":"instructions/#no-nav-mul_imm_st","title":"Opcode","text":"<p>0x3E</p>"},{"location":"instructions/#no-nav-mul_imm_st-operation","title":"Operation","text":"<p>Multiply top of stack by immediate</p>"},{"location":"instructions/#no-nav-mul_imm_st-operands","title":"Operands","text":"<p>i32 value</p>"},{"location":"instructions/#no-nav-mul_imm_st-acc","title":"Accumulator","text":"<p>No change</p>"},{"location":"instructions/#no-nav-mul_imm_st-stack","title":"Stack","text":"<p>[..., a] \u2192 [..., a * value]</p>"},{"location":"instructions/#no-nav-mul_imm_st-desc","title":"Description","text":"<p><code>a</code> must be a 64-bit integer. The top value of the stack is multiplied by the 32-bit immediate <code>value</code>. Overflow behavior is undefined, but never results in runtime errors.</p>"},{"location":"instructions/#div_imm_st","title":"DIV_IMM_ST","text":""},{"location":"instructions/#no-nav-div_imm_st","title":"Opcode","text":"<p>0x3F</p>"},{"location":"instructions/#no-nav-div_imm_st-operation","title":"Operation","text":"<p>Divide top of stack by immediate</p>"},{"location":"instructions/#no-nav-div_imm_st-operands","title":"Operands","text":"<p>i32 value</p>"},{"location":"instructions/#no-nav-div_imm_st-acc","title":"Accumulator","text":"<p>No change</p>"},{"location":"instructions/#no-nav-div_imm_st-stack","title":"Stack","text":"<p>[..., a] \u2192 [..., a / value]</p>"},{"location":"instructions/#no-nav-div_imm_st-desc","title":"Description","text":"<p><code>a</code> must be a 64-bit integer. The top value of the stack is divided by the 32-bit immediate <code>value</code>. Division of the most negative 64-bit value by -1 produces a result that cannot be represented. This case is undefined behavior, but does not raise a runtime error.</p>"},{"location":"instructions/#no-nav-div_imm_st-errors","title":"Errors","text":"<p>If the divisor is 0, causes a runtime error.</p>"},{"location":"instructions/#mod_imm_st","title":"MOD_IMM_ST","text":""},{"location":"instructions/#no-nav-mod_imm_st","title":"Opcode","text":"<p>0x40</p>"},{"location":"instructions/#no-nav-mod_imm_st-operation","title":"Operation","text":"<p>Modulo top of stack by immediate</p>"},{"location":"instructions/#no-nav-mod_imm_st-operands","title":"Operands","text":"<p>i32 value</p>"},{"location":"instructions/#no-nav-mod_imm_st-acc","title":"Accumulator","text":"<p>No change</p>"},{"location":"instructions/#no-nav-mod_imm_st-stack","title":"Stack","text":"<p>[..., a] \u2192 [..., result]</p>"},{"location":"instructions/#no-nav-mod_imm_st-desc","title":"Description","text":"<p><code>a</code> must be a 64-bit integer. The top value of the stack is replaced with the result of <code>a - (a / value) * value</code>. Applying modulo to the most negative 64-bit value with a divisor of -1 is undefined due to the underlying division step, but does not raise a runtime error.</p>"},{"location":"instructions/#no-nav-mod_imm_st-errors","title":"Errors","text":"<p>If the divisor is 0, causes a runtime error.</p>"},{"location":"instructions/#and_imm_st","title":"AND_IMM_ST","text":""},{"location":"instructions/#no-nav-and_imm_st","title":"Opcode","text":"<p>0x41</p>"},{"location":"instructions/#no-nav-and_imm_st-operation","title":"Operation","text":"<p>Bitwise AND top of stack with immediate</p>"},{"location":"instructions/#no-nav-and_imm_st-operands","title":"Operands","text":"<p>i32 value</p>"},{"location":"instructions/#no-nav-and_imm_st-acc","title":"Accumulator","text":"<p>No change</p>"},{"location":"instructions/#no-nav-and_imm_st-stack","title":"Stack","text":"<p>[..., a] \u2192 [..., a &amp; value]</p>"},{"location":"instructions/#no-nav-and_imm_st-desc","title":"Description","text":"<p><code>a</code> must be a 64-bit integer. The top value of the stack is set to the result of bitwise AND (conjunction) of <code>a</code> and the 32-bit immediate <code>value</code>.</p>"},{"location":"instructions/#or_imm_st","title":"OR_IMM_ST","text":""},{"location":"instructions/#no-nav-or_imm_st","title":"Opcode","text":"<p>0x42</p>"},{"location":"instructions/#no-nav-or_imm_st-operation","title":"Operation","text":"<p>Bitwise OR top of stack with immediate</p>"},{"location":"instructions/#no-nav-or_imm_st-operands","title":"Operands","text":"<p>i32 value</p>"},{"location":"instructions/#no-nav-or_imm_st-acc","title":"Accumulator","text":"<p>No change</p>"},{"location":"instructions/#no-nav-or_imm_st-stack","title":"Stack","text":"<p>[..., a] \u2192 [..., a | value]</p>"},{"location":"instructions/#no-nav-or_imm_st-desc","title":"Description","text":"<p><code>a</code> must be a 64-bit integer. The top value of the stack is set to the result of bitwise OR of <code>a</code> and the 32-bit immediate <code>value</code>.</p>"},{"location":"instructions/#xor_imm_st","title":"XOR_IMM_ST","text":""},{"location":"instructions/#no-nav-xor_imm_st","title":"Opcode","text":"<p>0x43</p>"},{"location":"instructions/#no-nav-xor_imm_st-operation","title":"Operation","text":"<p>Bitwise XOR top of stack with immediate</p>"},{"location":"instructions/#no-nav-xor_imm_st-operands","title":"Operands","text":"<p>i32 value</p>"},{"location":"instructions/#no-nav-xor_imm_st-acc","title":"Accumulator","text":"<p>No change</p>"},{"location":"instructions/#no-nav-xor_imm_st-stack","title":"Stack","text":"<p>[..., a] \u2192 [..., a ^ value]</p>"},{"location":"instructions/#no-nav-xor_imm_st-desc","title":"Description","text":"<p><code>a</code> must be a 64-bit integer. The top value of the stack is set to the result of bitwise exclusive OR of <code>a</code> and the 32-bit immediate <code>value</code>.</p>"},{"location":"instructions/#shl_imm_st","title":"SHL_IMM_ST","text":""},{"location":"instructions/#no-nav-shl_imm_st","title":"Opcode","text":"<p>0x44</p>"},{"location":"instructions/#no-nav-shl_imm_st-operation","title":"Operation","text":"<p>Shift left top of stack by immediate</p>"},{"location":"instructions/#no-nav-shl_imm_st-operands","title":"Operands","text":"<p>i32 value</p>"},{"location":"instructions/#no-nav-shl_imm_st-acc","title":"Accumulator","text":"<p>No change</p>"},{"location":"instructions/#no-nav-shl_imm_st-stack","title":"Stack","text":"<p>[..., a] \u2192 [..., a &lt;&lt; 0x3F]</p>"},{"location":"instructions/#no-nav-shl_imm_st-desc","title":"Description","text":"<p><code>a</code> must be a 64-bit integer. The top value of the stack is shifted left by <code>s</code> bit positions, where <code>s</code> is the value of the low 6 bits of the 32-bit immediate <code>value</code>.</p>"},{"location":"instructions/#shr_imm_st","title":"SHR_IMM_ST","text":""},{"location":"instructions/#no-nav-shr_imm_st","title":"Opcode","text":"<p>0x45</p>"},{"location":"instructions/#no-nav-shr_imm_st-operation","title":"Operation","text":"<p>Shift right top of stack by immediate</p>"},{"location":"instructions/#no-nav-shr_imm_st-operands","title":"Operands","text":"<p>i32 value</p>"},{"location":"instructions/#no-nav-shr_imm_st-acc","title":"Accumulator","text":"<p>No change</p>"},{"location":"instructions/#no-nav-shr_imm_st-stack","title":"Stack","text":"<p>[..., a] \u2192 [..., a &gt;&gt; value]</p>"},{"location":"instructions/#no-nav-shr_imm_st-desc","title":"Description","text":"<p><code>a</code> must be a 64-bit integer. The top value of the stack is shifted right by <code>s</code> bit positions, where <code>s</code> is the value of the low 6 bits of the 32-bit immediate <code>value</code>.</p>"},{"location":"instructions/#fadd","title":"FADD","text":""},{"location":"instructions/#no-nav-fadd","title":"Opcode","text":"<p>0x50</p>"},{"location":"instructions/#no-nav-fadd-operation","title":"Operation","text":"<p>Add floats</p>"},{"location":"instructions/#no-nav-fadd-operands","title":"Operands","text":"<p>None</p>"},{"location":"instructions/#no-nav-fadd-acc","title":"Accumulator","text":"<p>a \u2192 a + b</p>"},{"location":"instructions/#no-nav-fadd-stack","title":"Stack","text":"<p>[..., b] \u2192 [...]</p>"},{"location":"instructions/#no-nav-fadd-desc","title":"Description","text":"<p>Both <code>a</code> and <code>b</code> must be 64-bit floating-point values. <code>b</code> is popped from the stack and added to the accumulator <code>a</code>.</p>"},{"location":"instructions/#fsub","title":"FSUB","text":""},{"location":"instructions/#no-nav-fsub","title":"Opcode","text":"<p>0x51</p>"},{"location":"instructions/#no-nav-fsub-operation","title":"Operation","text":"<p>Subtract floats</p>"},{"location":"instructions/#no-nav-fsub-operands","title":"Operands","text":"<p>None</p>"},{"location":"instructions/#no-nav-fsub-acc","title":"Accumulator","text":"<p>a \u2192 a - b</p>"},{"location":"instructions/#no-nav-fsub-stack","title":"Stack","text":"<p>[..., b] \u2192 [...]</p>"},{"location":"instructions/#no-nav-fsub-desc","title":"Description","text":"<p>Both <code>a</code> and <code>b</code> must be 64-bit floating-point values. <code>b</code> is popped from the stack and subtracted from the accumulator <code>a</code>.</p>"},{"location":"instructions/#fmul","title":"FMUL","text":""},{"location":"instructions/#no-nav-fmul","title":"Opcode","text":"<p>0x52</p>"},{"location":"instructions/#no-nav-fmul-operation","title":"Operation","text":"<p>Multiply floats</p>"},{"location":"instructions/#no-nav-fmul-operands","title":"Operands","text":"<p>None</p>"},{"location":"instructions/#no-nav-fmul-acc","title":"Accumulator","text":"<p>a \u2192 a * b</p>"},{"location":"instructions/#no-nav-fmul-stack","title":"Stack","text":"<p>[..., b] \u2192 [...]</p>"},{"location":"instructions/#no-nav-fmul-desc","title":"Description","text":"<p>Both <code>a</code> and <code>b</code> must be 64-bit floating-point values. <code>b</code> is popped from the stack and multiplied with the accumulator <code>a</code>.</p>"},{"location":"instructions/#fdiv","title":"FDIV","text":""},{"location":"instructions/#no-nav-fdiv","title":"Opcode","text":"<p>0x53</p>"},{"location":"instructions/#no-nav-fdiv-operation","title":"Operation","text":"<p>Divide floats</p>"},{"location":"instructions/#no-nav-fdiv-operands","title":"Operands","text":"<p>None</p>"},{"location":"instructions/#no-nav-fdiv-acc","title":"Accumulator","text":"<p>a \u2192 a / b</p>"},{"location":"instructions/#no-nav-fdiv-stack","title":"Stack","text":"<p>[..., b] \u2192 [...]</p>"},{"location":"instructions/#no-nav-fdiv-desc","title":"Description","text":"<p>Both <code>a</code> and <code>b</code> must be 64-bit floating-point values. <code>b</code> is popped from the stack and the accumulator <code>a</code> is divided by <code>b</code>. If <code>b</code> is 0.0, the result is IEEE 754-defined (\u00b1Inf or NaN).</p>"},{"location":"instructions/#fadd2","title":"FADD2","text":""},{"location":"instructions/#no-nav-fadd2","title":"Opcode","text":"<p>0x54</p>"},{"location":"instructions/#no-nav-fadd2-operation","title":"Operation","text":"<p>Add floats</p>"},{"location":"instructions/#no-nav-fadd2-operands","title":"Operands","text":"<p>None</p>"},{"location":"instructions/#no-nav-fadd2-acc","title":"Accumulator","text":"<p>... \u2192 a + b</p>"},{"location":"instructions/#no-nav-fadd2-stack","title":"Stack","text":"<p>[..., a, b] \u2192 [...]</p>"},{"location":"instructions/#no-nav-fadd2-desc","title":"Description","text":"<p>Both <code>a</code> and <code>b</code> must be 64-bit floating-point values. The values are popped from the stack. The result <code>a + b</code> is moved to the accumulator.</p>"},{"location":"instructions/#fsub2","title":"FSUB2","text":""},{"location":"instructions/#no-nav-fsub2","title":"Opcode","text":"<p>0x55</p>"},{"location":"instructions/#no-nav-fsub2-operation","title":"Operation","text":"<p>Subtract floats</p>"},{"location":"instructions/#no-nav-fsub2-operands","title":"Operands","text":"<p>None</p>"},{"location":"instructions/#no-nav-fsub2-acc","title":"Accumulator","text":"<p>... \u2192 a - b</p>"},{"location":"instructions/#no-nav-fsub2-stack","title":"Stack","text":"<p>[..., a, b] \u2192 [...]</p>"},{"location":"instructions/#no-nav-fsub2-desc","title":"Description","text":"<p>Both <code>a</code> and <code>b</code> must be 64-bit floating-point values. The values are popped from the stack. The result <code>a - b</code> is moved to the accumulator.</p>"},{"location":"instructions/#fmul2","title":"FMUL2","text":""},{"location":"instructions/#no-nav-fmul2","title":"Opcode","text":"<p>0x56</p>"},{"location":"instructions/#no-nav-fmul2-operation","title":"Operation","text":"<p>Multiply floats</p>"},{"location":"instructions/#no-nav-fmul2-operands","title":"Operands","text":"<p>None</p>"},{"location":"instructions/#no-nav-fmul2-acc","title":"Accumulator","text":"<p>... \u2192 a * b</p>"},{"location":"instructions/#no-nav-fmul2-stack","title":"Stack","text":"<p>[..., a, b] \u2192 [...]</p>"},{"location":"instructions/#no-nav-fmul2-desc","title":"Description","text":"<p>Both <code>a</code> and <code>b</code> must be 64-bit floating-point values. The values are popped from the stack. The result <code>a * b</code> is moved to the accumulator.</p>"},{"location":"instructions/#fdiv2","title":"FDIV2","text":""},{"location":"instructions/#no-nav-fdiv2","title":"Opcode","text":"<p>0x57</p>"},{"location":"instructions/#no-nav-fdiv2-operation","title":"Operation","text":"<p>Divide floats</p>"},{"location":"instructions/#no-nav-fdiv2-operands","title":"Operands","text":"<p>None</p>"},{"location":"instructions/#no-nav-fdiv2-acc","title":"Accumulator","text":"<p>... \u2192 a / b</p>"},{"location":"instructions/#no-nav-fdiv2-stack","title":"Stack","text":"<p>[..., a, b] \u2192 [...]</p>"},{"location":"instructions/#no-nav-fdiv2-desc","title":"Description","text":"<p>Both <code>a</code> and <code>b</code> must be 64-bit floating-point values. The values are popped from the stack. The result <code>a / b</code> is moved to the accumulator. If <code>b</code> is 0.0, the result is IEEE 754-defined (\u00b1Inf or NaN).</p>"},{"location":"instructions/#fadd_st","title":"FADD_ST","text":""},{"location":"instructions/#no-nav-fadd_st","title":"Opcode","text":"<p>0x58</p>"},{"location":"instructions/#no-nav-fadd_st-operation","title":"Operation","text":"<p>Add floats</p>"},{"location":"instructions/#no-nav-fadd_st-operands","title":"Operands","text":"<p>None</p>"},{"location":"instructions/#no-nav-fadd_st-acc","title":"Accumulator","text":"<p>No change</p>"},{"location":"instructions/#no-nav-fadd_st-stack","title":"Stack","text":"<p>[..., a, b] \u2192 [..., a + b]</p>"},{"location":"instructions/#no-nav-fadd_st-desc","title":"Description","text":"<p>Both <code>a</code> and <code>b</code> must be 64-bit floating-point values. The values are popped from the stack and their sum is pushed back.</p>"},{"location":"instructions/#fsub_st","title":"FSUB_ST","text":""},{"location":"instructions/#no-nav-fsub_st","title":"Opcode","text":"<p>0x59</p>"},{"location":"instructions/#no-nav-fsub_st-operation","title":"Operation","text":"<p>Subtract floats</p>"},{"location":"instructions/#no-nav-fsub_st-operands","title":"Operands","text":"<p>None</p>"},{"location":"instructions/#no-nav-fsub_st-acc","title":"Accumulator","text":"<p>No change</p>"},{"location":"instructions/#no-nav-fsub_st-stack","title":"Stack","text":"<p>[..., a, b] \u2192 [..., a - b]</p>"},{"location":"instructions/#no-nav-fsub_st-desc","title":"Description","text":"<p>Both <code>a</code> and <code>b</code> must be 64-bit floating-point values. The values are popped from the stack and the difference is pushed back.</p>"},{"location":"instructions/#fmul_st","title":"FMUL_ST","text":""},{"location":"instructions/#no-nav-fmul_st","title":"Opcode","text":"<p>0x5A</p>"},{"location":"instructions/#no-nav-fmul_st-operation","title":"Operation","text":"<p>Multiply floats</p>"},{"location":"instructions/#no-nav-fmul_st-operands","title":"Operands","text":"<p>None</p>"},{"location":"instructions/#no-nav-fmul_st-acc","title":"Accumulator","text":"<p>No change</p>"},{"location":"instructions/#no-nav-fmul_st-stack","title":"Stack","text":"<p>[..., a, b] \u2192 [..., a * b]</p>"},{"location":"instructions/#no-nav-fmul_st-desc","title":"Description","text":"<p>Both <code>a</code> and <code>b</code> must be 64-bit floating-point values. The values are popped from the stack and the product is pushed back.</p>"},{"location":"instructions/#fdiv_st","title":"FDIV_ST","text":""},{"location":"instructions/#no-nav-fdiv_st","title":"Opcode","text":"<p>0x5B</p>"},{"location":"instructions/#no-nav-fdiv_st-operation","title":"Operation","text":"<p>Divide floats</p>"},{"location":"instructions/#no-nav-fdiv_st-operands","title":"Operands","text":"<p>None</p>"},{"location":"instructions/#no-nav-fdiv_st-acc","title":"Accumulator","text":"<p>No change</p>"},{"location":"instructions/#no-nav-fdiv_st-stack","title":"Stack","text":"<p>[..., a, b] \u2192 [..., a / b]</p>"},{"location":"instructions/#no-nav-fdiv_st-desc","title":"Description","text":"<p>Both <code>a</code> and <code>b</code> must be 64-bit floating-point values. The values are popped from the stack and the quotient is pushed back. If <code>b</code> is 0.0, the result is IEEE 754-defined (\u00b1Inf or NaN).</p>"},{"location":"instructions/#fneg","title":"FNEG","text":""},{"location":"instructions/#no-nav-fneg","title":"Opcode","text":"<p>0x5C</p>"},{"location":"instructions/#no-nav-fneg-operation","title":"Operation","text":"<p>Negate float</p>"},{"location":"instructions/#no-nav-fneg-operands","title":"Operands","text":"<p>None</p>"},{"location":"instructions/#no-nav-fneg-acc","title":"Accumulator","text":"<p>a \u2192 -a</p>"},{"location":"instructions/#no-nav-fneg-stack","title":"Stack","text":"<p>No change</p>"},{"location":"instructions/#no-nav-fneg-desc","title":"Description","text":"<p><code>a</code> must be a 64-bit floating-point value. The value in the accumulator is negated.</p>"},{"location":"instructions/#fadd_imm","title":"FADD_IMM","text":""},{"location":"instructions/#no-nav-fadd_imm","title":"Opcode","text":"<p>0x5D</p>"},{"location":"instructions/#no-nav-fadd_imm-operation","title":"Operation","text":"<p>Add float immediate</p>"},{"location":"instructions/#no-nav-fadd_imm-operands","title":"Operands","text":"<p>f32 value</p>"},{"location":"instructions/#no-nav-fadd_imm-acc","title":"Accumulator","text":"<p>a \u2192 a + value</p>"},{"location":"instructions/#no-nav-fadd_imm-stack","title":"Stack","text":"<p>No change</p>"},{"location":"instructions/#no-nav-fadd_imm-desc","title":"Description","text":"<p>Adds a 32-bit floating-point immediate <code>value</code> to the accumulator.</p>"},{"location":"instructions/#fsub_imm","title":"FSUB_IMM","text":""},{"location":"instructions/#no-nav-fsub_imm","title":"Opcode","text":"<p>0x5E</p>"},{"location":"instructions/#no-nav-fsub_imm-operation","title":"Operation","text":"<p>Subtract float immediate</p>"},{"location":"instructions/#no-nav-fsub_imm-operands","title":"Operands","text":"<p>f32 value</p>"},{"location":"instructions/#no-nav-fsub_imm-acc","title":"Accumulator","text":"<p>a \u2192 a - value</p>"},{"location":"instructions/#no-nav-fsub_imm-stack","title":"Stack","text":"<p>No change</p>"},{"location":"instructions/#no-nav-fsub_imm-desc","title":"Description","text":"<p>Subtracts a 32-bit floating-point immediate <code>value</code> from the accumulator.</p>"},{"location":"instructions/#fmul_imm","title":"FMUL_IMM","text":""},{"location":"instructions/#no-nav-fmul_imm","title":"Opcode","text":"<p>0x5F</p>"},{"location":"instructions/#no-nav-fmul_imm-operation","title":"Operation","text":"<p>Multiply by float immediate</p>"},{"location":"instructions/#no-nav-fmul_imm-operands","title":"Operands","text":"<p>f32 value</p>"},{"location":"instructions/#no-nav-fmul_imm-acc","title":"Accumulator","text":"<p>a \u2192 a * value</p>"},{"location":"instructions/#no-nav-fmul_imm-stack","title":"Stack","text":"<p>No change</p>"},{"location":"instructions/#no-nav-fmul_imm-desc","title":"Description","text":"<p>Multiplies the accumulator by a 32-bit floating-point immediate <code>value</code>.</p>"},{"location":"instructions/#fdiv_imm","title":"FDIV_IMM","text":""},{"location":"instructions/#no-nav-fdiv_imm","title":"Opcode","text":"<p>0x60</p>"},{"location":"instructions/#no-nav-fdiv_imm-operation","title":"Operation","text":"<p>Divide by float immediate</p>"},{"location":"instructions/#no-nav-fdiv_imm-operands","title":"Operands","text":"<p>f32 value</p>"},{"location":"instructions/#no-nav-fdiv_imm-acc","title":"Accumulator","text":"<p>a \u2192 a / value</p>"},{"location":"instructions/#no-nav-fdiv_imm-stack","title":"Stack","text":"<p>No change</p>"},{"location":"instructions/#no-nav-fdiv_imm-desc","title":"Description","text":"<p>Divides the accumulator by a 32-bit floating-point immediate <code>value</code>. If <code>value</code> is 0.0, the result is IEEE 754-defined (\u00b1Inf or NaN).</p>"},{"location":"instructions/#fadd_imm_st","title":"FADD_IMM_ST","text":""},{"location":"instructions/#no-nav-fadd_imm_st","title":"Opcode","text":"<p>0x61</p>"},{"location":"instructions/#no-nav-fadd_imm_st-operation","title":"Operation","text":"<p>Add float immediate to stack</p>"},{"location":"instructions/#no-nav-fadd_imm_st-operands","title":"Operands","text":"<p>f32 value</p>"},{"location":"instructions/#no-nav-fadd_imm_st-acc","title":"Accumulator","text":"<p>No change</p>"},{"location":"instructions/#no-nav-fadd_imm_st-stack","title":"Stack","text":"<p>[..., a] \u2192 [..., a + value]</p>"},{"location":"instructions/#no-nav-fadd_imm_st-desc","title":"Description","text":"<p>Pops the top float from the stack, adds a 32-bit immediate <code>value</code>, and pushes the result.</p>"},{"location":"instructions/#fsub_imm_st","title":"FSUB_IMM_ST","text":""},{"location":"instructions/#no-nav-fsub_imm_st","title":"Opcode","text":"<p>0x62</p>"},{"location":"instructions/#no-nav-fsub_imm_st-operation","title":"Operation","text":"<p>Subtract float immediate from stack</p>"},{"location":"instructions/#no-nav-fsub_imm_st-operands","title":"Operands","text":"<p>f32 value</p>"},{"location":"instructions/#no-nav-fsub_imm_st-acc","title":"Accumulator","text":"<p>No change</p>"},{"location":"instructions/#no-nav-fsub_imm_st-stack","title":"Stack","text":"<p>[..., a] \u2192 [..., a - value]</p>"},{"location":"instructions/#no-nav-fsub_imm_st-desc","title":"Description","text":"<p>Pops the top float from the stack, subtracts a 32-bit immediate <code>value</code>, and pushes the result.</p>"},{"location":"instructions/#fmul_imm_st","title":"FMUL_IMM_ST","text":""},{"location":"instructions/#no-nav-fmul_imm_st","title":"Opcode","text":"<p>0x63</p>"},{"location":"instructions/#no-nav-fmul_imm_st-operation","title":"Operation","text":"<p>Multiply stack top by float immediate</p>"},{"location":"instructions/#no-nav-fmul_imm_st-operands","title":"Operands","text":"<p>f32 value</p>"},{"location":"instructions/#no-nav-fmul_imm_st-acc","title":"Accumulator","text":"<p>No change</p>"},{"location":"instructions/#no-nav-fmul_imm_st-stack","title":"Stack","text":"<p>[..., a] \u2192 [..., a * value]</p>"},{"location":"instructions/#no-nav-fmul_imm_st-desc","title":"Description","text":"<p>Pops the top float from the stack, multiplies by a 32-bit immediate <code>value</code>, and pushes the result.</p>"},{"location":"instructions/#fdiv_imm_st","title":"FDIV_IMM_ST","text":""},{"location":"instructions/#no-nav-fdiv_imm_st","title":"Opcode","text":"<p>0x64</p>"},{"location":"instructions/#no-nav-fdiv_imm_st-operation","title":"Operation","text":"<p>Divide stack top by float immediate</p>"},{"location":"instructions/#no-nav-fdiv_imm_st-operands","title":"Operands","text":"<p>f32 value</p>"},{"location":"instructions/#no-nav-fdiv_imm_st-acc","title":"Accumulator","text":"<p>No change</p>"},{"location":"instructions/#no-nav-fdiv_imm_st-stack","title":"Stack","text":"<p>[..., a] \u2192 [..., a / value]</p>"},{"location":"instructions/#no-nav-fdiv_imm_st-desc","title":"Description","text":"<p>Pops the top float from the stack, divides by a 32-bit immediate <code>value</code>, and pushes the result. If <code>value</code> is 0.0, the result is IEEE 754-defined (\u00b1Inf or NaN).</p>"},{"location":"instructions/#cmp_eq","title":"CMP_EQ","text":""},{"location":"instructions/#no-nav-cmp_eq","title":"Opcode","text":"<p>0x65</p>"},{"location":"instructions/#no-nav-cmp_eq-operation","title":"Operation","text":"<p>Compare integers equal</p>"},{"location":"instructions/#no-nav-cmp_eq-operands","title":"Operands","text":"<p>None</p>"},{"location":"instructions/#no-nav-cmp_eq-acc","title":"Accumulator","text":"<p>a \u2192 a == b</p>"},{"location":"instructions/#no-nav-cmp_eq-stack","title":"Stack","text":"<p>[..., b] \u2192 [...]</p>"},{"location":"instructions/#no-nav-cmp_eq-desc","title":"Description","text":"<p>Both <code>a</code> and <code>b</code> must be 64-bit integers. <code>b</code> is popped from the stack. The result is <code>a == b</code> and is pushed to the stack.</p>"},{"location":"instructions/#cmp_ne","title":"CMP_NE","text":""},{"location":"instructions/#no-nav-cmp_ne","title":"Opcode","text":"<p>0x66</p>"},{"location":"instructions/#no-nav-cmp_ne-operation","title":"Operation","text":"<p>Compare integers not equal</p>"},{"location":"instructions/#no-nav-cmp_ne-operands","title":"Operands","text":"<p>None</p>"},{"location":"instructions/#no-nav-cmp_ne-acc","title":"Accumulator","text":"<p>a \u2192 a != b</p>"},{"location":"instructions/#no-nav-cmp_ne-stack","title":"Stack","text":"<p>[..., b] \u2192 [...]</p>"},{"location":"instructions/#no-nav-cmp_ne-desc","title":"Description","text":"<p>Both <code>a</code> and <code>b</code> must be 64-bit integers. <code>b</code> is popped from the stack. The result is <code>a != b</code> and is pushed to the stack.</p>"},{"location":"instructions/#cmp_lt","title":"CMP_LT","text":""},{"location":"instructions/#no-nav-cmp_lt","title":"Opcode","text":"<p>0x67</p>"},{"location":"instructions/#no-nav-cmp_lt-operation","title":"Operation","text":"<p>Compare integers less than</p>"},{"location":"instructions/#no-nav-cmp_lt-operands","title":"Operands","text":"<p>None</p>"},{"location":"instructions/#no-nav-cmp_lt-acc","title":"Accumulator","text":"<p>a \u2192 a &lt; b</p>"},{"location":"instructions/#no-nav-cmp_lt-stack","title":"Stack","text":"<p>[..., b] \u2192 [...]</p>"},{"location":"instructions/#no-nav-cmp_lt-desc","title":"Description","text":"<p>Both <code>a</code> and <code>b</code> must be 64-bit integers. <code>b</code> is popped from the stack. The result is <code>a &lt; b</code> and is pushed to the stack.</p>"},{"location":"instructions/#cmp_gt","title":"CMP_GT","text":""},{"location":"instructions/#no-nav-cmp_gt","title":"Opcode","text":"<p>0x68</p>"},{"location":"instructions/#no-nav-cmp_gt-operation","title":"Operation","text":"<p>Compare integers greater than</p>"},{"location":"instructions/#no-nav-cmp_gt-operands","title":"Operands","text":"<p>None</p>"},{"location":"instructions/#no-nav-cmp_gt-acc","title":"Accumulator","text":"<p>a \u2192 a &gt; b</p>"},{"location":"instructions/#no-nav-cmp_gt-stack","title":"Stack","text":"<p>[..., b] \u2192 [...]</p>"},{"location":"instructions/#no-nav-cmp_gt-desc","title":"Description","text":"<p>Both <code>a</code> and <code>b</code> must be 64-bit integers. <code>b</code> is popped from the stack. The result is <code>a &gt; b</code> and is pushed to the stack.</p>"},{"location":"instructions/#cmp_lte","title":"CMP_LTE","text":""},{"location":"instructions/#no-nav-cmp_lte","title":"Opcode","text":"<p>0x69</p>"},{"location":"instructions/#no-nav-cmp_lte-operation","title":"Operation","text":"<p>Compare integers less than or equal</p>"},{"location":"instructions/#no-nav-cmp_lte-operands","title":"Operands","text":"<p>None</p>"},{"location":"instructions/#no-nav-cmp_lte-acc","title":"Accumulator","text":"<p>a \u2192 a &lt;= b</p>"},{"location":"instructions/#no-nav-cmp_lte-stack","title":"Stack","text":"<p>[..., b] \u2192 [...]</p>"},{"location":"instructions/#no-nav-cmp_lte-desc","title":"Description","text":"<p>Both <code>a</code> and <code>b</code> must be 64-bit integers. <code>b</code> is popped from the stack. The result is <code>a &lt;= b</code> and is pushed to the stack.</p>"},{"location":"instructions/#cmp_gte","title":"CMP_GTE","text":""},{"location":"instructions/#no-nav-cmp_gte","title":"Opcode","text":"<p>0x6A</p>"},{"location":"instructions/#no-nav-cmp_gte-operation","title":"Operation","text":"<p>Compare integers greater than or equal</p>"},{"location":"instructions/#no-nav-cmp_gte-operands","title":"Operands","text":"<p>None</p>"},{"location":"instructions/#no-nav-cmp_gte-acc","title":"Accumulator","text":"<p>a \u2192 a &gt;= b</p>"},{"location":"instructions/#no-nav-cmp_gte-stack","title":"Stack","text":"<p>[..., b] \u2192 [...]</p>"},{"location":"instructions/#no-nav-cmp_gte-desc","title":"Description","text":"<p>Both <code>a</code> and <code>b</code> must be 64-bit integers. <code>b</code> is popped from the stack. The result is <code>a &gt;= b</code> and is pushed to the stack.</p>"},{"location":"instructions/#fcmp_eq","title":"FCMP_EQ","text":""},{"location":"instructions/#no-nav-fcmp_eq","title":"Opcode","text":"<p>0x6B</p>"},{"location":"instructions/#no-nav-fcmp_eq-operation","title":"Operation","text":"<p>Compare floats equal</p>"},{"location":"instructions/#no-nav-fcmp_eq-operands","title":"Operands","text":"<p>None</p>"},{"location":"instructions/#no-nav-fcmp_eq-acc","title":"Accumulator","text":"<p>a \u2192 a == b</p>"},{"location":"instructions/#no-nav-fcmp_eq-stack","title":"Stack","text":"<p>[..., b] \u2192 [...]</p>"},{"location":"instructions/#no-nav-fcmp_eq-desc","title":"Description","text":"<p>Both <code>a</code> and <code>b</code> must be 64-bit floats. <code>b</code> is popped from the stack. The result is <code>a == b</code> and is pushed to the stack.</p>"},{"location":"instructions/#fcmp_ne","title":"FCMP_NE","text":""},{"location":"instructions/#no-nav-fcmp_ne","title":"Opcode","text":"<p>0x6C</p>"},{"location":"instructions/#no-nav-fcmp_ne-operation","title":"Operation","text":"<p>Compare floats not equal</p>"},{"location":"instructions/#no-nav-fcmp_ne-operands","title":"Operands","text":"<p>None</p>"},{"location":"instructions/#no-nav-fcmp_ne-acc","title":"Accumulator","text":"<p>a \u2192 a != b</p>"},{"location":"instructions/#no-nav-fcmp_ne-stack","title":"Stack","text":"<p>[..., b] \u2192 [...]</p>"},{"location":"instructions/#no-nav-fcmp_ne-desc","title":"Description","text":"<p>Both <code>a</code> and <code>b</code> must be 64-bit floats. <code>b</code> is popped from the stack. The result is <code>a != b</code> and is pushed to the stack.</p>"},{"location":"instructions/#fcmp_lt","title":"FCMP_LT","text":""},{"location":"instructions/#no-nav-fcmp_lt","title":"Opcode","text":"<p>0x6D</p>"},{"location":"instructions/#no-nav-fcmp_lt-operation","title":"Operation","text":"<p>Compare floats less than</p>"},{"location":"instructions/#no-nav-fcmp_lt-operands","title":"Operands","text":"<p>None</p>"},{"location":"instructions/#no-nav-fcmp_lt-acc","title":"Accumulator","text":"<p>a \u2192 a &lt; b</p>"},{"location":"instructions/#no-nav-fcmp_lt-stack","title":"Stack","text":"<p>[..., b] \u2192 [...]</p>"},{"location":"instructions/#no-nav-fcmp_lt-desc","title":"Description","text":"<p>Both <code>a</code> and <code>b</code> must be 64-bit floats. <code>b</code> is popped from the stack. The result is <code>a &lt; b</code> and is pushed to the stack.</p>"},{"location":"instructions/#fcmp_gt","title":"FCMP_GT","text":""},{"location":"instructions/#no-nav-fcmp_gt","title":"Opcode","text":"<p>0x6E</p>"},{"location":"instructions/#no-nav-fcmp_gt-operation","title":"Operation","text":"<p>Compare floats greater than</p>"},{"location":"instructions/#no-nav-fcmp_gt-operands","title":"Operands","text":"<p>None</p>"},{"location":"instructions/#no-nav-fcmp_gt-acc","title":"Accumulator","text":"<p>a \u2192 a &gt; b</p>"},{"location":"instructions/#no-nav-fcmp_gt-stack","title":"Stack","text":"<p>[..., b] \u2192 [...]</p>"},{"location":"instructions/#no-nav-fcmp_gt-desc","title":"Description","text":"<p>Both <code>a</code> and <code>b</code> must be 64-bit floats. <code>b</code> is popped from the stack. The result is <code>a &gt; b</code> and is pushed to the stack.</p>"},{"location":"instructions/#fcmp_lte","title":"FCMP_LTE","text":""},{"location":"instructions/#no-nav-fcmp_lte","title":"Opcode","text":"<p>0x6F</p>"},{"location":"instructions/#no-nav-fcmp_lte-operation","title":"Operation","text":"<p>Compare floats less than or equal</p>"},{"location":"instructions/#no-nav-fcmp_lte-operands","title":"Operands","text":"<p>None</p>"},{"location":"instructions/#no-nav-fcmp_lte-acc","title":"Accumulator","text":"<p>a \u2192 a &lt;= b</p>"},{"location":"instructions/#no-nav-fcmp_lte-stack","title":"Stack","text":"<p>[..., b] \u2192 [...]</p>"},{"location":"instructions/#no-nav-fcmp_lte-desc","title":"Description","text":"<p>Both <code>a</code> and <code>b</code> must be 64-bit floats. <code>b</code> is popped from the stack. The result is <code>a &lt;= b</code> and is pushed to the stack.</p>"},{"location":"instructions/#fcmp_gte","title":"FCMP_GTE","text":""},{"location":"instructions/#no-nav-fcmp_gte","title":"Opcode","text":"<p>0x70</p>"},{"location":"instructions/#no-nav-fcmp_gte-operation","title":"Operation","text":"<p>Compare floats greater than or equal</p>"},{"location":"instructions/#no-nav-fcmp_gte-operands","title":"Operands","text":"<p>None</p>"},{"location":"instructions/#no-nav-fcmp_gte-acc","title":"Accumulator","text":"<p>a \u2192 a &gt;= b</p>"},{"location":"instructions/#no-nav-fcmp_gte-stack","title":"Stack","text":"<p>[..., b] \u2192 [...]</p>"},{"location":"instructions/#no-nav-fcmp_gte-desc","title":"Description","text":"<p>Both <code>a</code> and <code>b</code> must be 64-bit floats. <code>b</code> is popped from the stack. The result is <code>a &gt;= b</code> and is pushed to the stack.</p>"},{"location":"instructions/#cmp_eq0","title":"CMP_EQ0","text":""},{"location":"instructions/#no-nav-cmp_eq0","title":"Opcode","text":"<p>0x71</p>"},{"location":"instructions/#no-nav-cmp_eq0-operation","title":"Operation","text":"<p>Compare integer to zero</p>"},{"location":"instructions/#no-nav-cmp_eq0-operands","title":"Operands","text":"<p>None</p>"},{"location":"instructions/#no-nav-cmp_eq0-acc","title":"Accumulator","text":"<p>a \u2192 a == 0</p>"},{"location":"instructions/#no-nav-cmp_eq0-stack","title":"Stack","text":"<p>No change</p>"},{"location":"instructions/#no-nav-cmp_eq0-desc","title":"Description","text":"<p><code>a</code> must be a 64-bit integer. The result is <code>a == 0</code> and is pushed to the stack.</p>"},{"location":"instructions/#cmp_ne0","title":"CMP_NE0","text":""},{"location":"instructions/#no-nav-cmp_ne0","title":"Opcode","text":"<p>0x72</p>"},{"location":"instructions/#no-nav-cmp_ne0-operation","title":"Operation","text":"<p>Compare integer to zero</p>"},{"location":"instructions/#no-nav-cmp_ne0-operands","title":"Operands","text":"<p>None</p>"},{"location":"instructions/#no-nav-cmp_ne0-acc","title":"Accumulator","text":"<p>a \u2192 a != 0</p>"},{"location":"instructions/#no-nav-cmp_ne0-stack","title":"Stack","text":"<p>No change</p>"},{"location":"instructions/#no-nav-cmp_ne0-desc","title":"Description","text":"<p><code>a</code> must be a 64-bit integer. The result is <code>a != 0</code> and is pushed to the stack.</p>"},{"location":"instructions/#cmp_lt0","title":"CMP_LT0","text":""},{"location":"instructions/#no-nav-cmp_lt0","title":"Opcode","text":"<p>0x73</p>"},{"location":"instructions/#no-nav-cmp_lt0-operation","title":"Operation","text":"<p>Compare integer to zero</p>"},{"location":"instructions/#no-nav-cmp_lt0-operands","title":"Operands","text":"<p>None</p>"},{"location":"instructions/#no-nav-cmp_lt0-acc","title":"Accumulator","text":"<p>a \u2192 a &lt; 0</p>"},{"location":"instructions/#no-nav-cmp_lt0-stack","title":"Stack","text":"<p>No change</p>"},{"location":"instructions/#no-nav-cmp_lt0-desc","title":"Description","text":"<p><code>a</code> must be a 64-bit integer. The result is <code>a &lt; 0</code> and is pushed to the stack.</p>"},{"location":"instructions/#cmp_gt0","title":"CMP_GT0","text":""},{"location":"instructions/#no-nav-cmp_gt0","title":"Opcode","text":"<p>0x74</p>"},{"location":"instructions/#no-nav-cmp_gt0-operation","title":"Operation","text":"<p>Compare integer to zero</p>"},{"location":"instructions/#no-nav-cmp_gt0-operands","title":"Operands","text":"<p>None</p>"},{"location":"instructions/#no-nav-cmp_gt0-acc","title":"Accumulator","text":"<p>a \u2192 a &gt; 0</p>"},{"location":"instructions/#no-nav-cmp_gt0-stack","title":"Stack","text":"<p>No change</p>"},{"location":"instructions/#no-nav-cmp_gt0-desc","title":"Description","text":"<p><code>a</code> must be a 64-bit integer. The result is <code>a &gt; 0</code> and is pushed to the stack.</p>"},{"location":"instructions/#cmp_lte0","title":"CMP_LTE0","text":""},{"location":"instructions/#no-nav-cmp_lte0","title":"Opcode","text":"<p>0x75</p>"},{"location":"instructions/#no-nav-cmp_lte0-operation","title":"Operation","text":"<p>Compare integer to zero</p>"},{"location":"instructions/#no-nav-cmp_lte0-operands","title":"Operands","text":"<p>None</p>"},{"location":"instructions/#no-nav-cmp_lte0-acc","title":"Accumulator","text":"<p>a \u2192 a &lt;= 0</p>"},{"location":"instructions/#no-nav-cmp_lte0-stack","title":"Stack","text":"<p>No change</p>"},{"location":"instructions/#no-nav-cmp_lte0-desc","title":"Description","text":"<p><code>a</code> must be a 64-bit integer. The result is <code>a &lt;= 0</code> and is pushed to the stack.</p>"},{"location":"instructions/#cmp_gte0","title":"CMP_GTE0","text":""},{"location":"instructions/#no-nav-cmp_gte0","title":"Opcode","text":"<p>0x76</p>"},{"location":"instructions/#no-nav-cmp_gte0-operation","title":"Operation","text":"<p>Compare integer to zero</p>"},{"location":"instructions/#no-nav-cmp_gte0-operands","title":"Operands","text":"<p>None</p>"},{"location":"instructions/#no-nav-cmp_gte0-acc","title":"Accumulator","text":"<p>a \u2192 a &gt;= 0</p>"},{"location":"instructions/#no-nav-cmp_gte0-stack","title":"Stack","text":"<p>No change</p>"},{"location":"instructions/#no-nav-cmp_gte0-desc","title":"Description","text":"<p><code>a</code> must be a 64-bit integer. The result is <code>a &gt;= 0</code> and is pushed to the stack.</p>"},{"location":"instructions/#fcmp_eq0","title":"FCMP_EQ0","text":""},{"location":"instructions/#no-nav-fcmp_eq0","title":"Opcode","text":"<p>0x77</p>"},{"location":"instructions/#no-nav-fcmp_eq0-operation","title":"Operation","text":"<p>Compare float to zero</p>"},{"location":"instructions/#no-nav-fcmp_eq0-operands","title":"Operands","text":"<p>None</p>"},{"location":"instructions/#no-nav-fcmp_eq0-acc","title":"Accumulator","text":"<p>a \u2192 a == 0f</p>"},{"location":"instructions/#no-nav-fcmp_eq0-stack","title":"Stack","text":"<p>No change</p>"},{"location":"instructions/#no-nav-fcmp_eq0-desc","title":"Description","text":"<p><code>a</code> must be a 64-bit float. The result is <code>a == 0.0</code> and is pushed to the stack.</p>"},{"location":"instructions/#fcmp_ne0","title":"FCMP_NE0","text":""},{"location":"instructions/#no-nav-fcmp_ne0","title":"Opcode","text":"<p>0x78</p>"},{"location":"instructions/#no-nav-fcmp_ne0-operation","title":"Operation","text":"<p>Compare float to zero</p>"},{"location":"instructions/#no-nav-fcmp_ne0-operands","title":"Operands","text":"<p>None</p>"},{"location":"instructions/#no-nav-fcmp_ne0-acc","title":"Accumulator","text":"<p>a \u2192 a != 0f</p>"},{"location":"instructions/#no-nav-fcmp_ne0-stack","title":"Stack","text":"<p>No change</p>"},{"location":"instructions/#no-nav-fcmp_ne0-desc","title":"Description","text":"<p><code>a</code> must be a 64-bit float. The result is <code>a != 0.0</code> and is pushed to the stack.</p>"},{"location":"instructions/#fcmp_lt0","title":"FCMP_LT0","text":""},{"location":"instructions/#no-nav-fcmp_lt0","title":"Opcode","text":"<p>0x79</p>"},{"location":"instructions/#no-nav-fcmp_lt0-operation","title":"Operation","text":"<p>Compare float to zero</p>"},{"location":"instructions/#no-nav-fcmp_lt0-operands","title":"Operands","text":"<p>None</p>"},{"location":"instructions/#no-nav-fcmp_lt0-acc","title":"Accumulator","text":"<p>a \u2192 a &lt; 0f</p>"},{"location":"instructions/#no-nav-fcmp_lt0-stack","title":"Stack","text":"<p>No change</p>"},{"location":"instructions/#no-nav-fcmp_lt0-desc","title":"Description","text":"<p><code>a</code> must be a 64-bit float. The result is <code>a &lt; 0.0</code> and is pushed to the stack.</p>"},{"location":"instructions/#fcmp_gt0","title":"FCMP_GT0","text":""},{"location":"instructions/#no-nav-fcmp_gt0","title":"Opcode","text":"<p>0x7A</p>"},{"location":"instructions/#no-nav-fcmp_gt0-operation","title":"Operation","text":"<p>Compare float to zero</p>"},{"location":"instructions/#no-nav-fcmp_gt0-operands","title":"Operands","text":"<p>None</p>"},{"location":"instructions/#no-nav-fcmp_gt0-acc","title":"Accumulator","text":"<p>a \u2192 a &gt; 0f</p>"},{"location":"instructions/#no-nav-fcmp_gt0-stack","title":"Stack","text":"<p>No change</p>"},{"location":"instructions/#no-nav-fcmp_gt0-desc","title":"Description","text":"<p><code>a</code> must be a 64-bit float. The result is <code>a &gt; 0.0</code> and is pushed to the stack.</p>"},{"location":"instructions/#fcmp_lte0","title":"FCMP_LTE0","text":""},{"location":"instructions/#no-nav-fcmp_lte0","title":"Opcode","text":"<p>0x7B</p>"},{"location":"instructions/#no-nav-fcmp_lte0-operation","title":"Operation","text":"<p>Compare float to zero</p>"},{"location":"instructions/#no-nav-fcmp_lte0-operands","title":"Operands","text":"<p>None</p>"},{"location":"instructions/#no-nav-fcmp_lte0-acc","title":"Accumulator","text":"<p>a \u2192 a &lt;= 0f</p>"},{"location":"instructions/#no-nav-fcmp_lte0-stack","title":"Stack","text":"<p>No change</p>"},{"location":"instructions/#no-nav-fcmp_lte0-desc","title":"Description","text":"<p><code>a</code> must be a 64-bit float. The result is <code>a &lt;= 0.0</code> and is pushed to the stack.</p>"},{"location":"instructions/#fcmp_gte0","title":"FCMP_GTE0","text":""},{"location":"instructions/#no-nav-fcmp_gte0","title":"Opcode","text":"<p>0x7C</p>"},{"location":"instructions/#no-nav-fcmp_gte0-operation","title":"Operation","text":"<p>Compare float to zero</p>"},{"location":"instructions/#no-nav-fcmp_gte0-operands","title":"Operands","text":"<p>None</p>"},{"location":"instructions/#no-nav-fcmp_gte0-acc","title":"Accumulator","text":"<p>a \u2192 a &gt;= 0f</p>"},{"location":"instructions/#no-nav-fcmp_gte0-stack","title":"Stack","text":"<p>No change</p>"},{"location":"instructions/#no-nav-fcmp_gte0-desc","title":"Description","text":"<p><code>a</code> must be a 64-bit float. The result is <code>a &gt;= 0.0</code> and is pushed to the stack.</p>"},{"location":"instructions/#push_acc","title":"PUSH_ACC","text":""},{"location":"instructions/#no-nav-push_acc","title":"Opcode","text":"<p>0x80</p>"},{"location":"instructions/#no-nav-push_acc-operation","title":"Operation","text":"<p>Push accumulator</p>"},{"location":"instructions/#no-nav-push_acc-operands","title":"Operands","text":"<p>None</p>"},{"location":"instructions/#no-nav-push_acc-acc","title":"Accumulator","text":"<p>No change</p>"},{"location":"instructions/#no-nav-push_acc-stack","title":"Stack","text":"<p>[...] \u2192 [..., acc]</p>"},{"location":"instructions/#no-nav-push_acc-desc","title":"Description","text":"<p><code>acc</code> is the current 64-bit value in the accumulator. <code>acc</code> is pushed onto the stack.</p>"},{"location":"instructions/#push_sp","title":"PUSH_SP","text":""},{"location":"instructions/#no-nav-push_sp","title":"Opcode","text":"<p>0x81</p>"},{"location":"instructions/#no-nav-push_sp-operation","title":"Operation","text":"<p>Push stack pointer</p>"},{"location":"instructions/#no-nav-push_sp-operands","title":"Operands","text":"<p>None</p>"},{"location":"instructions/#no-nav-push_sp-acc","title":"Accumulator","text":"<p>No change</p>"},{"location":"instructions/#no-nav-push_sp-stack","title":"Stack","text":"<p>[...] \u2192 [..., sp]</p>"},{"location":"instructions/#no-nav-push_sp-desc","title":"Description","text":"<p><code>sp</code> is the current 64-bit value in the stack pointer register. <code>sp</code> is pushed onto the stack.</p>"},{"location":"instructions/#no-nav-push_sp-notes","title":"Notes","text":"<p>The stack pointer will never be a real memory pointer in sandbox mode. Other than that, its value is implementation-defined.</p>"},{"location":"instructions/#pop_acc","title":"POP_ACC","text":""},{"location":"instructions/#no-nav-pop_acc","title":"Opcode","text":"<p>0x82</p>"},{"location":"instructions/#no-nav-pop_acc-operation","title":"Operation","text":"<p>Pop stack value into accumulator</p>"},{"location":"instructions/#no-nav-pop_acc-operands","title":"Operands","text":"<p>None</p>"},{"location":"instructions/#no-nav-pop_acc-acc","title":"Accumulator","text":"<p>... \u2192 value</p>"},{"location":"instructions/#no-nav-pop_acc-stack","title":"Stack","text":"<p>[..., value] \u2192 [...]</p>"},{"location":"instructions/#no-nav-pop_acc-desc","title":"Description","text":"<p>The topmost stack value is popped and moved into the accumulator.</p>"},{"location":"instructions/#pop_sp","title":"POP_SP","text":""},{"location":"instructions/#no-nav-pop_sp","title":"Opcode","text":"<p>0x83</p>"},{"location":"instructions/#no-nav-pop_sp-operation","title":"Operation","text":"<p>Pop stack value into stack pointer</p>"},{"location":"instructions/#no-nav-pop_sp-operands","title":"Operands","text":"<p>None</p>"},{"location":"instructions/#no-nav-pop_sp-acc","title":"Accumulator","text":"<p>No change</p>"},{"location":"instructions/#no-nav-pop_sp-sp","title":"Stack Pointer (Register)","text":"<p>... \u2192 value</p>"},{"location":"instructions/#no-nav-pop_sp-stack","title":"Stack","text":"<p>[..., value] \u2192 [...]</p>"},{"location":"instructions/#no-nav-pop_sp-desc","title":"Description","text":"<p>The topmost stack value is popped and moved into the stack pointer register.</p>"},{"location":"instructions/#pop_discard","title":"POP_DISCARD","text":""},{"location":"instructions/#no-nav-pop_discard","title":"Opcode","text":"<p>0x84</p>"},{"location":"instructions/#no-nav-pop_discard-operation","title":"Operation","text":"<p>Pop <code>n</code> stack values and discard them</p>"},{"location":"instructions/#no-nav-pop_discard-operands","title":"Operands","text":"<p>u8 n</p>"},{"location":"instructions/#no-nav-pop_discard-acc","title":"Accumulator","text":"<p>No change</p>"},{"location":"instructions/#no-nav-pop_discard-stack","title":"Stack","text":"<p>[..., [elem1, ...]] \u2192 [...]</p>"},{"location":"instructions/#no-nav-pop_discard-desc","title":"Description","text":"<p>Pops <code>n</code> elements from the stack and discards their values.</p>"},{"location":"instructions/#const","title":"CONST","text":""},{"location":"instructions/#no-nav-const","title":"Opcode","text":"<p>0x85</p>"},{"location":"instructions/#no-nav-const-operation","title":"Operation","text":"<p>Move constant value into accumulator</p>"},{"location":"instructions/#no-nav-const-operands","title":"Operands","text":"<p>i8 value</p>"},{"location":"instructions/#no-nav-const-acc","title":"Accumulator","text":"<p>... \u2192 value</p>"},{"location":"instructions/#no-nav-const-stack","title":"Stack","text":"<p>No change</p>"},{"location":"instructions/#no-nav-const-desc","title":"Description","text":"<p>Loads an 8-bit immediate value and moves it into the accumulator.</p>"},{"location":"instructions/#const32","title":"CONST32","text":""},{"location":"instructions/#no-nav-const32","title":"Opcode","text":"<p>0x86</p>"},{"location":"instructions/#no-nav-const32-operation","title":"Operation","text":"<p>Move constant value into accumulator</p>"},{"location":"instructions/#no-nav-const32-operands","title":"Operands","text":"<p>i32 value</p>"},{"location":"instructions/#no-nav-const32-acc","title":"Accumulator","text":"<p>... \u2192 value</p>"},{"location":"instructions/#no-nav-const32-stack","title":"Stack","text":"<p>No change</p>"},{"location":"instructions/#no-nav-const32-desc","title":"Description","text":"<p>Loads an 32-bit immediate value and moves it into the accumulator.</p>"},{"location":"instructions/#const64","title":"CONST64","text":""},{"location":"instructions/#no-nav-const64","title":"Opcode","text":"<p>0x87</p>"},{"location":"instructions/#no-nav-const64-operation","title":"Operation","text":"<p>Move constant value into accumulator</p>"},{"location":"instructions/#no-nav-const64-operands","title":"Operands","text":"<p>i64 value</p>"},{"location":"instructions/#no-nav-const64-acc","title":"Accumulator","text":"<p>... \u2192 value</p>"},{"location":"instructions/#no-nav-const64-stack","title":"Stack","text":"<p>No change</p>"},{"location":"instructions/#no-nav-const64-desc","title":"Description","text":"<p>Loads an 64-bit immediate value and moves it into the accumulator.</p>"},{"location":"instructions/#const_st","title":"CONST_ST","text":""},{"location":"instructions/#no-nav-const_st","title":"Opcode","text":"<p>0x88</p>"},{"location":"instructions/#no-nav-const_st-operation","title":"Operation","text":"<p>Push constant value to stack</p>"},{"location":"instructions/#no-nav-const_st-operands","title":"Operands","text":"<p>i8 value</p>"},{"location":"instructions/#no-nav-const_st-acc","title":"Accumulator","text":"<p>... \u2192 value</p>"},{"location":"instructions/#no-nav-const_st-stack","title":"Stack","text":"<p>No change</p>"},{"location":"instructions/#no-nav-const_st-desc","title":"Description","text":"<p>Loads an 8-bit immediate value and pushes it to the stack.</p>"},{"location":"instructions/#const32_st","title":"CONST32_ST","text":""},{"location":"instructions/#no-nav-const32_st","title":"Opcode","text":"<p>0x89</p>"},{"location":"instructions/#no-nav-const32_st-operation","title":"Operation","text":"<p>Push constant value to stack</p>"},{"location":"instructions/#no-nav-const32_st-operands","title":"Operands","text":"<p>i32 value</p>"},{"location":"instructions/#no-nav-const32_st-acc","title":"Accumulator","text":"<p>... \u2192 value</p>"},{"location":"instructions/#no-nav-const32_st-stack","title":"Stack","text":"<p>No change</p>"},{"location":"instructions/#no-nav-const32_st-desc","title":"Description","text":"<p>Loads an 32-bit immediate value and pushes it to the stack.</p>"},{"location":"instructions/#const64_st","title":"CONST64_ST","text":""},{"location":"instructions/#no-nav-const64_st","title":"Opcode","text":"<p>0x8A</p>"},{"location":"instructions/#no-nav-const64_st-operation","title":"Operation","text":"<p>Push constant value to stack</p>"},{"location":"instructions/#no-nav-const64_st-operands","title":"Operands","text":"<p>i64 value</p>"},{"location":"instructions/#no-nav-const64_st-acc","title":"Accumulator","text":"<p>... \u2192 value</p>"},{"location":"instructions/#no-nav-const64_st-stack","title":"Stack","text":"<p>No change</p>"},{"location":"instructions/#no-nav-const64_st-desc","title":"Description","text":"<p>Loads an 64-bit immediate value and pushes it to the stack.</p>"},{"location":"instructions/#load","title":"LOAD","text":""},{"location":"instructions/#no-nav-load","title":"Opcode","text":"<p>0x8B</p>"},{"location":"instructions/#no-nav-load-operation","title":"Operation","text":"<p>Load stack value into accumulator</p>"},{"location":"instructions/#no-nav-load-operands","title":"Operands","text":"<p>i16 index</p>"},{"location":"instructions/#no-nav-load-acc","title":"Accumulator","text":"<p>... \u2192 value</p>"},{"location":"instructions/#no-nav-load-stack","title":"Stack","text":"<p>No change</p>"},{"location":"instructions/#no-nav-load-desc","title":"Description","text":"<p>The way this instruction loads a value depends on whether <code>index</code> is positive or negative. If <code>index</code> is positive (&gt;= 0), load from the current frame's stack base plus <code>index</code>. If <code>index</code> is negative (&lt; 0), load from the stack pointer register minus the absolute value of <code>index</code>.  For example, a given <code>index</code> of -1 would load the topmost stack value, and a given <code>index</code> of 0 would load the first stack value.</p>"},{"location":"instructions/#load_st","title":"LOAD_ST","text":""},{"location":"instructions/#no-nav-load_st","title":"Opcode","text":"<p>0x8C</p>"},{"location":"instructions/#no-nav-load_st-operation","title":"Operation","text":"<p>Load stack value and push to stack</p>"},{"location":"instructions/#no-nav-load_st-operands","title":"Operands","text":"<p>i16 index</p>"},{"location":"instructions/#no-nav-load_st-acc","title":"Accumulator","text":"<p>No change</p>"},{"location":"instructions/#no-nav-load_st-stack","title":"Stack","text":"<p>[...] \u2192 [..., value]</p>"},{"location":"instructions/#no-nav-load_st-desc","title":"Description","text":"<p>The way this instruction loads a value depends on whether <code>index</code> is positive or negative. If <code>index</code> is positive (&gt;= 0), load from the current frame\u2019s stack base plus <code>index</code>. If <code>index</code> is negative (&lt; 0), load from the stack pointer register minus the absolute value of <code>index</code>.  For example, an <code>index</code> of -1 would load the topmost stack value and push it, while an <code>index</code> of 0 would load the first stack value and push it.</p>"},{"location":"instructions/#store","title":"STORE","text":""},{"location":"instructions/#no-nav-store","title":"Opcode","text":"<p>0x8D</p>"},{"location":"instructions/#no-nav-store-operation","title":"Operation","text":"<p>Store accumulator value in stack</p>"},{"location":"instructions/#no-nav-store-operands","title":"Operands","text":"<p>i16 index</p>"},{"location":"instructions/#no-nav-store-acc","title":"Accumulator","text":"<p>No change</p>"},{"location":"instructions/#no-nav-store-stack","title":"Stack","text":"<p>No change</p>"},{"location":"instructions/#no-nav-store-desc","title":"Description","text":"<p>The way this instruction stores a value depends on whether <code>index</code> is positive or negative. If <code>index</code> is positive (&gt;= 0), store to the current frame\u2019s stack base plus <code>index</code>. If <code>index</code> is negative (&lt; 0), store to the stack pointer register minus the absolute value of <code>index</code>.  For example, an <code>index</code> of -1 stores the accumulator to the topmost stack slot, while an <code>index</code> of 0 stores to the first slot.</p>"},{"location":"instructions/#store_st","title":"STORE_ST","text":""},{"location":"instructions/#no-nav-store_st","title":"Opcode","text":"<p>0x8E</p>"},{"location":"instructions/#no-nav-store_st-operation","title":"Operation","text":"<p>Pop value and store in stack</p>"},{"location":"instructions/#no-nav-store_st-operands","title":"Operands","text":"<p>i16 index</p>"},{"location":"instructions/#no-nav-store_st-acc","title":"Accumulator","text":"<p>No change</p>"},{"location":"instructions/#no-nav-store_st-stack","title":"Stack","text":"<p>[..., value] \u2192 [...]</p>"},{"location":"instructions/#no-nav-store_st-desc","title":"Description","text":"<p>The way this instruction stores a value depends on whether <code>index</code> is positive or negative. If <code>index</code> is positive (&gt;= 0), store to the current frame\u2019s stack base plus <code>index</code>. If <code>index</code> is negative (&lt; 0), store to the stack pointer register minus the absolute value of <code>index</code> before the value is popped.  For example, an <code>index</code> of -1 stores the popped value to the topmost slot before popping, while an <code>index</code> of 0 stores to the first slot.</p>"},{"location":"instructions/#reserve","title":"RESERVE","text":""},{"location":"instructions/#no-nav-reserve","title":"Opcode","text":"<p>0x8F</p>"},{"location":"instructions/#no-nav-reserve-operation","title":"Operation","text":"<p>Reserve slots on the stack</p>"},{"location":"instructions/#no-nav-reserve-operands","title":"Operands","text":"<p>u8 count</p>"},{"location":"instructions/#no-nav-reserve-acc","title":"Accumulator","text":"<p>No change</p>"},{"location":"instructions/#no-nav-reserve-stack","title":"Stack","text":"<p>[...] \u2192 [..., _ x count]</p>"},{"location":"instructions/#no-nav-reserve-desc","title":"Description","text":"<p>Allocates <code>count</code> uninitialized slots on the stack. These slots are meant to be used for local storage. No values are popped or written. This operation is the equivalent of <code>sp += count</code>.</p>"},{"location":"instructions/#jmp","title":"JMP","text":""},{"location":"instructions/#no-nav-jmp","title":"Opcode","text":"<p>0x97</p>"},{"location":"instructions/#no-nav-jmp-operation","title":"Operation","text":"<p>Branch always</p>"},{"location":"instructions/#no-nav-jmp-operands","title":"Operands","text":"<p>i16 branch</p>"},{"location":"instructions/#no-nav-jmp-acc","title":"Accumulator","text":"<p>No change</p>"},{"location":"instructions/#no-nav-jmp-stack","title":"Stack","text":"<p>No change</p>"},{"location":"instructions/#no-nav-jmp-desc","title":"Description","text":"<p>Unconditionally increments the program counter by <code>branch</code> as a signed integer.</p>"},{"location":"instructions/#jz","title":"JZ","text":""},{"location":"instructions/#no-nav-jz","title":"Opcode","text":"<p>0x98</p>"},{"location":"instructions/#no-nav-jz-operation","title":"Operation","text":"<p>Branch if zero</p>"},{"location":"instructions/#no-nav-jz-operands","title":"Operands","text":"<p>i16 branch</p>"},{"location":"instructions/#no-nav-jz-acc","title":"Accumulator","text":"<p>No change</p>"},{"location":"instructions/#no-nav-jz-stack","title":"Stack","text":"<p>No change</p>"},{"location":"instructions/#no-nav-jz-desc","title":"Description","text":"<p>Increments the program counter by <code>branch</code> as a signed integer if the value in the accumulator is equal to 0.</p>"},{"location":"instructions/#jnz","title":"JNZ","text":""},{"location":"instructions/#no-nav-jnz","title":"Opcode","text":"<p>0x99</p>"},{"location":"instructions/#no-nav-jnz-operation","title":"Operation","text":"<p>Branch if not zero</p>"},{"location":"instructions/#no-nav-jnz-operands","title":"Operands","text":"<p>i16 branch</p>"},{"location":"instructions/#no-nav-jnz-acc","title":"Accumulator","text":"<p>No change</p>"},{"location":"instructions/#no-nav-jnz-stack","title":"Stack","text":"<p>No change</p>"},{"location":"instructions/#no-nav-jnz-desc","title":"Description","text":"<p>Increments the program counter by <code>branch</code> as a signed integer if the value in the accumulator is not equal to 0.</p>"},{"location":"instructions/#call","title":"CALL","text":""},{"location":"instructions/#no-nav-call","title":"Opcode","text":"<p>0x9A</p>"},{"location":"instructions/#no-nav-call-operation","title":"Operation","text":"<p>Invoke CallEntry</p>"},{"location":"instructions/#no-nav-call-operands","title":"Operands","text":"<p>u32 target, u8 argc</p>"},{"location":"instructions/#no-nav-call-acc","title":"Accumulator","text":"<p>... \u2192 garbage or a return value</p>"},{"location":"instructions/#no-nav-call-stack","title":"Stack","text":"<p>[..., [arg1, ...]] \u2192 [...]</p>"},{"location":"instructions/#no-nav-call-desc","title":"Description","text":"<p><code>target</code> is an address pointing to a <code>CallEntry</code> within the data section.  The stack must contain <code>argc</code> values.  For simplicity, we will refer to the addressed <code>CallEntry</code> as 'the function.' This does not mean that a <code>CallEntry</code> always has to be a function symbol.  If the function is not yet resolved, its module and entry point are resolved and cached for future use.  If the function is not native, the <code>argc</code> values are popped from the stack. A new stack frame is created on the current thread.  The <code>argc</code> values are pushed in reverse order so that they appear in the same order on the new frame as they were in the previous frame. The new frame is then made the current, and the program counter is set to the specified entry of the function.  If the function is native, the <code>argc</code> values are popped from the stack and are passed as parameters to the implementation of the function. The code is executed in an implementation-dependent manner. When the platform-dependent code returns, the return value storage is moved to the accumulator regardless of the functions return type.  In the case of a void function, the accumulator will contain garbage data.</p>"},{"location":"instructions/#call_ex","title":"CALL_EX","text":""},{"location":"instructions/#no-nav-call_ex","title":"Opcode","text":"<p>0x9B</p>"},{"location":"instructions/#no-nav-call_ex-operation","title":"Operation","text":"<p>Invoke CallEntry</p>"},{"location":"instructions/#no-nav-call_ex-operands","title":"Operands","text":"<p>u32 target, u16 argc</p>"},{"location":"instructions/#no-nav-call_ex-acc","title":"Accumulator","text":"<p>... \u2192 garbage or a return value</p>"},{"location":"instructions/#no-nav-call_ex-stack","title":"Stack","text":"<p>[.., [arg1, ...]] \u2192 [...]</p>"},{"location":"instructions/#no-nav-call_ex-desc","title":"Description","text":"<p>Works like the CALL instruction, but with a wide <code>argc</code> operand.</p>"},{"location":"instructions/#call_dyn","title":"CALL_DYN","text":""},{"location":"instructions/#no-nav-call_dyn","title":"Opcode","text":"<p>0x9C</p>"},{"location":"instructions/#no-nav-call_dyn-operation","title":"Operation","text":"<p>Invoke CallEntry dynamically</p>"},{"location":"instructions/#no-nav-call_dyn-operands","title":"Operands","text":"<p>u16 argc</p>"},{"location":"instructions/#no-nav-call_dyn-acc","title":"Accumulator","text":"<p>target \u2192 garbage or a return value</p>"},{"location":"instructions/#no-nav-call_dyn-stack","title":"Stack","text":"<p>[.., [arg1, ...]] \u2192 [...]</p>"},{"location":"instructions/#no-nav-call_dyn-desc","title":"Description","text":"<p>Works like the CALL_EX instruction, but the target address is determined at runtime.  The target address is taken from the low 32 bits of the accumulator and treated as an unsigned 32-bit integer. This instruction is meant to be used with dynamic method dispatch, not on its own.</p>"},{"location":"instructions/#call_tiny","title":"CALL_TINY","text":""},{"location":"instructions/#no-nav-call_tiny","title":"Opcode","text":"<p>0x9D</p>"},{"location":"instructions/#no-nav-call_tiny-operation","title":"Operation","text":"<p>Invoke CallEntry</p>"},{"location":"instructions/#no-nav-call_tiny-operands","title":"Operands","text":"<p>u16 target, u8 argc</p>"},{"location":"instructions/#no-nav-call_tiny-acc","title":"Accumulator","text":"<p>... \u2192 garbage or a return value</p>"},{"location":"instructions/#no-nav-call_tiny-stack","title":"Stack","text":"<p>[.., [arg1, ...]] \u2192 [...]</p>"},{"location":"instructions/#no-nav-call_tiny-desc","title":"Description","text":"<p>Works like the CALL instruction, but with a narrow <code>target</code> operand.</p>"},{"location":"instructions/#call_tiny_ex","title":"CALL_TINY_EX","text":""},{"location":"instructions/#no-nav-call_tiny_ex","title":"Opcode","text":"<p>0x9E</p>"},{"location":"instructions/#no-nav-call_tiny_ex-operation","title":"Operation","text":"<p>Invoke CallEntry</p>"},{"location":"instructions/#no-nav-call_tiny_ex-operands","title":"Operands","text":"<p>u16 target, u16 argc</p>"},{"location":"instructions/#no-nav-call_tiny_ex-acc","title":"Accumulator","text":"<p>... \u2192 garbage or a return value</p>"},{"location":"instructions/#no-nav-call_tiny_ex-stack","title":"Stack","text":"<p>[.., [arg1, ...]] \u2192 [...]</p>"},{"location":"instructions/#no-nav-call_tiny_ex-desc","title":"Description","text":"<p>Works like the CALL instruction, but with a narrow <code>target</code> operand and wide <code>argc</code> operand.</p>"},{"location":"instructions/#ret","title":"RET","text":""},{"location":"instructions/#no-nav-ret","title":"Opcode","text":"<p>0x9F</p>"},{"location":"instructions/#no-nav-ret-operation","title":"Operation","text":"<p>Return from callable</p>"},{"location":"instructions/#no-nav-ret-operands","title":"Operands","text":"<p>None</p>"},{"location":"instructions/#no-nav-ret-acc","title":"Accumulator","text":"<p>No change</p>"},{"location":"instructions/#no-nav-ret-stack","title":"Stack","text":"<p>[...] \u2192 empty</p>"},{"location":"instructions/#no-nav-ret-desc","title":"Description","text":"<p>Any values on the current stack frame are discarded. The interpreter then returns control to the caller by updating the program counter to a saved value.</p>"},{"location":"overview/","title":"Overview","text":"<p>This document is still work in progress and some sections or entire chapters have not yet been written. If you have any questions, wait until the full Bibble Virtual Machine technical specification has been released.</p>"},{"location":"overview/#the-purpose-of-bibblevm","title":"The Purpose of BibbleVM","text":"<p>BibbleVM is engineered with performance as the top priority. To reach that goal, it omits many runtime safety mechanisms found in modern virtual machines.  There is no dynamic type checking, no runtime-enforced function constraints, and no implicit validation.  The VM assumes that compilers and assemblers emit correct code, following the same trust model as native machine code.  However, this does not eliminate the ability to run untrusted code. BibbleVM provides a clearly defined sandboxing mode that restricts all interaction with the host environment. The sandbox is enforced inside the VM and cannot be bypassed without explicitly loading unsafe, user-approved libraries. This mode is controlled entirely by the embedding host: the standalone BibbleVM distribution always runs in trusted mode.  BibbleVM supports both automatic storage management via classes, objects and a conservative garbage collection algorithm and manual storage management via explicit allocation and raw memory operations. Both approaches integrate cleanly with the VM's object model, and manual memory operations remain functional in sandboxed mode, where they operate under tightened safety rules.  The execution model is built around deterministic 8-byte slots and a broad, specialized instruction set designed for performance rather than compactness.  Each operation has a clearly defined behavior to keep compilation straightforward and interpreter overhead low.  Finally, BibbleVM is designed for seamless integration into larger systems.  Together with its compiler, the VM forms a fast, statically typed, compiled environment that can replace the typical embedded scripting engines used today.  The execution model, binary format, and host interface are all structured to make embedding straightforward and predictable.</p>"}]}